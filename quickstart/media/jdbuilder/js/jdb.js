(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["UIkit"] = factory();
	else
		root["UIkit"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/uikit.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://UIkit/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://UIkit/./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://UIkit/./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://UIkit/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/uikit.js":
/*!***********************************!*\
  !*** ./src/uikit.js + 42 modules ***!
  \***********************************/
/*! exports provided: default */
/*! ModuleConcatenation bailout: Cannot concat with ./src/util/lang.js because of ./src/util/promise.js */
/*! ModuleConcatenation bailout: Cannot concat with ./src/util/promise.js (<- Module uses injected variables (setImmediate)) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar util_namespaceObject = {};\n__webpack_require__.r(util_namespaceObject);\n__webpack_require__.d(util_namespaceObject, \"transition\", function() { return animation_transition; });\n__webpack_require__.d(util_namespaceObject, \"Transition\", function() { return Transition; });\n__webpack_require__.d(util_namespaceObject, \"animate\", function() { return animation_animate; });\n__webpack_require__.d(util_namespaceObject, \"Animation\", function() { return Animation; });\n__webpack_require__.d(util_namespaceObject, \"attr\", function() { return attr; });\n__webpack_require__.d(util_namespaceObject, \"hasAttr\", function() { return hasAttr; });\n__webpack_require__.d(util_namespaceObject, \"removeAttr\", function() { return removeAttr; });\n__webpack_require__.d(util_namespaceObject, \"data\", function() { return attr_data; });\n__webpack_require__.d(util_namespaceObject, \"addClass\", function() { return addClass; });\n__webpack_require__.d(util_namespaceObject, \"removeClass\", function() { return removeClass; });\n__webpack_require__.d(util_namespaceObject, \"removeClasses\", function() { return removeClasses; });\n__webpack_require__.d(util_namespaceObject, \"replaceClass\", function() { return replaceClass; });\n__webpack_require__.d(util_namespaceObject, \"hasClass\", function() { return hasClass; });\n__webpack_require__.d(util_namespaceObject, \"toggleClass\", function() { return toggleClass; });\n__webpack_require__.d(util_namespaceObject, \"positionAt\", function() { return positionAt; });\n__webpack_require__.d(util_namespaceObject, \"offset\", function() { return dimensions_offset; });\n__webpack_require__.d(util_namespaceObject, \"position\", function() { return dimensions_position; });\n__webpack_require__.d(util_namespaceObject, \"height\", function() { return dimensions_height; });\n__webpack_require__.d(util_namespaceObject, \"width\", function() { return dimensions_width; });\n__webpack_require__.d(util_namespaceObject, \"boxModelAdjust\", function() { return boxModelAdjust; });\n__webpack_require__.d(util_namespaceObject, \"flipPosition\", function() { return flipPosition; });\n__webpack_require__.d(util_namespaceObject, \"isInView\", function() { return isInView; });\n__webpack_require__.d(util_namespaceObject, \"scrolledOver\", function() { return scrolledOver; });\n__webpack_require__.d(util_namespaceObject, \"scrollTop\", function() { return scrollTop; });\n__webpack_require__.d(util_namespaceObject, \"offsetPosition\", function() { return offsetPosition; });\n__webpack_require__.d(util_namespaceObject, \"toPx\", function() { return toPx; });\n__webpack_require__.d(util_namespaceObject, \"ready\", function() { return ready; });\n__webpack_require__.d(util_namespaceObject, \"index\", function() { return dom_index; });\n__webpack_require__.d(util_namespaceObject, \"getIndex\", function() { return getIndex; });\n__webpack_require__.d(util_namespaceObject, \"empty\", function() { return empty; });\n__webpack_require__.d(util_namespaceObject, \"html\", function() { return dom_html; });\n__webpack_require__.d(util_namespaceObject, \"prepend\", function() { return prepend; });\n__webpack_require__.d(util_namespaceObject, \"append\", function() { return append; });\n__webpack_require__.d(util_namespaceObject, \"before\", function() { return before; });\n__webpack_require__.d(util_namespaceObject, \"after\", function() { return after; });\n__webpack_require__.d(util_namespaceObject, \"remove\", function() { return remove; });\n__webpack_require__.d(util_namespaceObject, \"wrapAll\", function() { return wrapAll; });\n__webpack_require__.d(util_namespaceObject, \"wrapInner\", function() { return wrapInner; });\n__webpack_require__.d(util_namespaceObject, \"unwrap\", function() { return unwrap; });\n__webpack_require__.d(util_namespaceObject, \"fragment\", function() { return fragment; });\n__webpack_require__.d(util_namespaceObject, \"apply\", function() { return dom_apply; });\n__webpack_require__.d(util_namespaceObject, \"$\", function() { return $; });\n__webpack_require__.d(util_namespaceObject, \"$$\", function() { return $$; });\n__webpack_require__.d(util_namespaceObject, \"isIE\", function() { return isIE; });\n__webpack_require__.d(util_namespaceObject, \"isRtl\", function() { return isRtl; });\n__webpack_require__.d(util_namespaceObject, \"hasTouch\", function() { return hasTouch; });\n__webpack_require__.d(util_namespaceObject, \"pointerDown\", function() { return pointerDown; });\n__webpack_require__.d(util_namespaceObject, \"pointerMove\", function() { return pointerMove; });\n__webpack_require__.d(util_namespaceObject, \"pointerUp\", function() { return pointerUp; });\n__webpack_require__.d(util_namespaceObject, \"pointerEnter\", function() { return pointerEnter; });\n__webpack_require__.d(util_namespaceObject, \"pointerLeave\", function() { return pointerLeave; });\n__webpack_require__.d(util_namespaceObject, \"pointerCancel\", function() { return pointerCancel; });\n__webpack_require__.d(util_namespaceObject, \"on\", function() { return on; });\n__webpack_require__.d(util_namespaceObject, \"off\", function() { return event_off; });\n__webpack_require__.d(util_namespaceObject, \"once\", function() { return once; });\n__webpack_require__.d(util_namespaceObject, \"trigger\", function() { return trigger; });\n__webpack_require__.d(util_namespaceObject, \"createEvent\", function() { return createEvent; });\n__webpack_require__.d(util_namespaceObject, \"toEventTargets\", function() { return toEventTargets; });\n__webpack_require__.d(util_namespaceObject, \"isTouch\", function() { return isTouch; });\n__webpack_require__.d(util_namespaceObject, \"getEventPos\", function() { return getEventPos; });\n__webpack_require__.d(util_namespaceObject, \"fastdom\", function() { return fastdom; });\n__webpack_require__.d(util_namespaceObject, \"isVoidElement\", function() { return isVoidElement; });\n__webpack_require__.d(util_namespaceObject, \"isVisible\", function() { return isVisible; });\n__webpack_require__.d(util_namespaceObject, \"selInput\", function() { return selInput; });\n__webpack_require__.d(util_namespaceObject, \"isInput\", function() { return isInput; });\n__webpack_require__.d(util_namespaceObject, \"filter\", function() { return filter_filter; });\n__webpack_require__.d(util_namespaceObject, \"within\", function() { return within; });\n__webpack_require__.d(util_namespaceObject, \"bind\", function() { return lang[\"bind\"]; });\n__webpack_require__.d(util_namespaceObject, \"hasOwn\", function() { return lang[\"hasOwn\"]; });\n__webpack_require__.d(util_namespaceObject, \"hyphenate\", function() { return lang[\"hyphenate\"]; });\n__webpack_require__.d(util_namespaceObject, \"camelize\", function() { return lang[\"camelize\"]; });\n__webpack_require__.d(util_namespaceObject, \"ucfirst\", function() { return lang[\"ucfirst\"]; });\n__webpack_require__.d(util_namespaceObject, \"startsWith\", function() { return lang[\"startsWith\"]; });\n__webpack_require__.d(util_namespaceObject, \"endsWith\", function() { return lang[\"endsWith\"]; });\n__webpack_require__.d(util_namespaceObject, \"includes\", function() { return lang[\"includes\"]; });\n__webpack_require__.d(util_namespaceObject, \"findIndex\", function() { return lang[\"findIndex\"]; });\n__webpack_require__.d(util_namespaceObject, \"isArray\", function() { return lang[\"isArray\"]; });\n__webpack_require__.d(util_namespaceObject, \"isFunction\", function() { return lang[\"isFunction\"]; });\n__webpack_require__.d(util_namespaceObject, \"isObject\", function() { return lang[\"isObject\"]; });\n__webpack_require__.d(util_namespaceObject, \"isPlainObject\", function() { return lang[\"isPlainObject\"]; });\n__webpack_require__.d(util_namespaceObject, \"isWindow\", function() { return lang[\"isWindow\"]; });\n__webpack_require__.d(util_namespaceObject, \"isDocument\", function() { return lang[\"isDocument\"]; });\n__webpack_require__.d(util_namespaceObject, \"isJQuery\", function() { return lang[\"isJQuery\"]; });\n__webpack_require__.d(util_namespaceObject, \"isNode\", function() { return lang[\"isNode\"]; });\n__webpack_require__.d(util_namespaceObject, \"isNodeCollection\", function() { return lang[\"isNodeCollection\"]; });\n__webpack_require__.d(util_namespaceObject, \"isBoolean\", function() { return lang[\"isBoolean\"]; });\n__webpack_require__.d(util_namespaceObject, \"isString\", function() { return lang[\"isString\"]; });\n__webpack_require__.d(util_namespaceObject, \"isNumber\", function() { return lang[\"isNumber\"]; });\n__webpack_require__.d(util_namespaceObject, \"isNumeric\", function() { return lang[\"isNumeric\"]; });\n__webpack_require__.d(util_namespaceObject, \"isEmpty\", function() { return lang[\"isEmpty\"]; });\n__webpack_require__.d(util_namespaceObject, \"isUndefined\", function() { return lang[\"isUndefined\"]; });\n__webpack_require__.d(util_namespaceObject, \"toBoolean\", function() { return lang[\"toBoolean\"]; });\n__webpack_require__.d(util_namespaceObject, \"toNumber\", function() { return lang[\"toNumber\"]; });\n__webpack_require__.d(util_namespaceObject, \"toFloat\", function() { return lang[\"toFloat\"]; });\n__webpack_require__.d(util_namespaceObject, \"toNode\", function() { return lang[\"toNode\"]; });\n__webpack_require__.d(util_namespaceObject, \"toNodes\", function() { return lang[\"toNodes\"]; });\n__webpack_require__.d(util_namespaceObject, \"toList\", function() { return lang[\"toList\"]; });\n__webpack_require__.d(util_namespaceObject, \"toMs\", function() { return lang[\"toMs\"]; });\n__webpack_require__.d(util_namespaceObject, \"isEqual\", function() { return lang[\"isEqual\"]; });\n__webpack_require__.d(util_namespaceObject, \"swap\", function() { return lang[\"swap\"]; });\n__webpack_require__.d(util_namespaceObject, \"assign\", function() { return lang[\"assign\"]; });\n__webpack_require__.d(util_namespaceObject, \"each\", function() { return lang[\"each\"]; });\n__webpack_require__.d(util_namespaceObject, \"sortBy\", function() { return lang[\"sortBy\"]; });\n__webpack_require__.d(util_namespaceObject, \"uniqueBy\", function() { return lang[\"uniqueBy\"]; });\n__webpack_require__.d(util_namespaceObject, \"clamp\", function() { return lang[\"clamp\"]; });\n__webpack_require__.d(util_namespaceObject, \"noop\", function() { return lang[\"noop\"]; });\n__webpack_require__.d(util_namespaceObject, \"intersectRect\", function() { return lang[\"intersectRect\"]; });\n__webpack_require__.d(util_namespaceObject, \"pointInRect\", function() { return lang[\"pointInRect\"]; });\n__webpack_require__.d(util_namespaceObject, \"Dimensions\", function() { return lang[\"Dimensions\"]; });\n__webpack_require__.d(util_namespaceObject, \"mergeOptions\", function() { return mergeOptions; });\n__webpack_require__.d(util_namespaceObject, \"parseOptions\", function() { return parseOptions; });\n__webpack_require__.d(util_namespaceObject, \"Promise\", function() { return util_promise[\"Promise\"]; });\n__webpack_require__.d(util_namespaceObject, \"Deferred\", function() { return util_promise[\"Deferred\"]; });\n__webpack_require__.d(util_namespaceObject, \"query\", function() { return query; });\n__webpack_require__.d(util_namespaceObject, \"queryAll\", function() { return queryAll; });\n__webpack_require__.d(util_namespaceObject, \"find\", function() { return find; });\n__webpack_require__.d(util_namespaceObject, \"findAll\", function() { return findAll; });\n__webpack_require__.d(util_namespaceObject, \"matches\", function() { return selector_matches; });\n__webpack_require__.d(util_namespaceObject, \"closest\", function() { return closest; });\n__webpack_require__.d(util_namespaceObject, \"parents\", function() { return parents; });\n__webpack_require__.d(util_namespaceObject, \"escape\", function() { return selector_escape; });\n__webpack_require__.d(util_namespaceObject, \"css\", function() { return style_css; });\n__webpack_require__.d(util_namespaceObject, \"getStyles\", function() { return getStyles; });\n__webpack_require__.d(util_namespaceObject, \"getStyle\", function() { return getStyle; });\n__webpack_require__.d(util_namespaceObject, \"getCssVar\", function() { return getCssVar; });\n__webpack_require__.d(util_namespaceObject, \"propName\", function() { return style_propName; });\n\n// EXTERNAL MODULE: ./src/util/lang.js\nvar lang = __webpack_require__(\"./src/util/lang.js\");\n\n// CONCATENATED MODULE: ./src/util/attr.js\n\n\nfunction attr(element, name, value) {\n\n    if (Object(lang[\"isObject\"])(name)) {\n        for (const key in name) {\n            attr(element, key, name[key]);\n        }\n        return;\n    }\n\n    if (Object(lang[\"isUndefined\"])(value)) {\n        element = Object(lang[\"toNode\"])(element);\n        return element && element.getAttribute(name);\n    } else {\n        Object(lang[\"toNodes\"])(element).forEach(element => {\n\n            if (Object(lang[\"isFunction\"])(value)) {\n                value = value.call(element, attr(element, name));\n            }\n\n            if (value === null) {\n                removeAttr(element, name);\n            } else {\n                element.setAttribute(name, value);\n            }\n        });\n    }\n\n}\n\nfunction hasAttr(element, name) {\n    return Object(lang[\"toNodes\"])(element).some(element => element.hasAttribute(name));\n}\n\nfunction removeAttr(element, name) {\n    element = Object(lang[\"toNodes\"])(element);\n    name.split(' ').forEach(name =>\n        element.forEach(element =>\n            element.hasAttribute(name) && element.removeAttribute(name)\n        )\n    );\n}\n\nfunction attr_data(element, attribute) {\n    for (let i = 0, attrs = [attribute, `data-${attribute}`]; i < attrs.length; i++) {\n        if (hasAttr(element, attrs[i])) {\n            return attr(element, attrs[i]);\n        }\n    }\n}\n\n// EXTERNAL MODULE: ./src/util/promise.js\nvar util_promise = __webpack_require__(\"./src/util/promise.js\");\n\n// CONCATENATED MODULE: ./src/util/selector.js\n\n\n\nfunction query(selector, context) {\n    return Object(lang[\"toNode\"])(selector) || find(selector, getContext(selector, context));\n}\n\nfunction queryAll(selector, context) {\n    const nodes = Object(lang[\"toNodes\"])(selector);\n    return nodes.length && nodes || findAll(selector, getContext(selector, context));\n}\n\nfunction getContext(selector, context = document) {\n    return isContextSelector(selector) || Object(lang[\"isDocument\"])(context)\n        ? context\n        : context.ownerDocument;\n}\n\nfunction find(selector, context) {\n    return Object(lang[\"toNode\"])(_query(selector, context, 'querySelector'));\n}\n\nfunction findAll(selector, context) {\n    return Object(lang[\"toNodes\"])(_query(selector, context, 'querySelectorAll'));\n}\n\nfunction _query(selector, context = document, queryFn) {\n\n    if (!selector || !Object(lang[\"isString\"])(selector)) {\n        return null;\n    }\n\n    selector = selector.replace(contextSanitizeRe, '$1 *');\n\n    let removes;\n\n    if (isContextSelector(selector)) {\n\n        removes = [];\n\n        selector = splitSelector(selector).map((selector, i) => {\n\n            let ctx = context;\n\n            if (selector[0] === '!') {\n\n                const selectors = selector.substr(1).trim().split(' ');\n                ctx = closest(context.parentNode, selectors[0]);\n                selector = selectors.slice(1).join(' ').trim();\n\n            }\n\n            if (selector[0] === '-') {\n\n                const selectors = selector.substr(1).trim().split(' ');\n                const prev = (ctx || context).previousElementSibling;\n                ctx = selector_matches(prev, selector.substr(1)) ? prev : null;\n                selector = selectors.slice(1).join(' ');\n\n            }\n\n            if (!ctx) {\n                return null;\n            }\n\n            if (!ctx.id) {\n                ctx.id = `jdb-${Date.now()}${i}`;\n                removes.push(() => removeAttr(ctx, 'id'));\n            }\n\n            return `#${selector_escape(ctx.id)} ${selector}`;\n\n        }).filter(Boolean).join(',');\n\n        context = document;\n\n    }\n\n    try {\n\n        return context[queryFn](selector);\n\n    } catch (e) {\n\n        return null;\n\n    } finally {\n\n        removes && removes.forEach(remove => remove());\n\n    }\n\n}\n\nconst contextSelectorRe = /(^|[^\\\\],)\\s*[!>+~-]/;\nconst contextSanitizeRe = /([!>+~-])(?=\\s+[!>+~-]|\\s*$)/g;\n\nfunction isContextSelector(selector) {\n    return Object(lang[\"isString\"])(selector) && selector.match(contextSelectorRe);\n}\n\nconst selectorRe = /.*?[^\\\\](?:,|$)/g;\n\nfunction splitSelector(selector) {\n    return selector.match(selectorRe).map(selector => selector.replace(/,$/, '').trim());\n}\n\nconst elProto = Element.prototype;\nconst matchesFn = elProto.matches || elProto.webkitMatchesSelector || elProto.msMatchesSelector;\n\nfunction selector_matches(element, selector) {\n    return Object(lang[\"toNodes\"])(element).some(element => matchesFn.call(element, selector));\n}\n\nconst closestFn = elProto.closest || function (selector) {\n    let ancestor = this;\n\n    do {\n\n        if (selector_matches(ancestor, selector)) {\n            return ancestor;\n        }\n\n        ancestor = ancestor.parentNode;\n\n    } while (ancestor && ancestor.nodeType === 1);\n};\n\nfunction closest(element, selector) {\n\n    if (Object(lang[\"startsWith\"])(selector, '>')) {\n        selector = selector.slice(1);\n    }\n\n    return Object(lang[\"isNode\"])(element)\n        ? element.parentNode && closestFn.call(element, selector)\n        : Object(lang[\"toNodes\"])(element).map(element => closest(element, selector)).filter(Boolean);\n}\n\nfunction parents(element, selector) {\n    const elements = [];\n    let parent = Object(lang[\"toNode\"])(element).parentNode;\n\n    while (parent && parent.nodeType === 1) {\n\n        if (selector_matches(parent, selector)) {\n            elements.push(parent);\n        }\n\n        parent = parent.parentNode;\n    }\n\n    return elements;\n}\n\nconst escapeFn = window.CSS && CSS.escape || function (css) { return css.replace(/([^\\x7f-\\uFFFF\\w-])/g, match => `\\\\${match}`); };\nfunction selector_escape(css) {\n    return Object(lang[\"isString\"])(css) ? escapeFn.call(null, css) : '';\n}\n\n// CONCATENATED MODULE: ./src/util/filter.js\n\n\n\nconst voidElements = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    menuitem: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true\n};\nfunction isVoidElement(element) {\n    return Object(lang[\"toNodes\"])(element).some(element => voidElements[element.tagName.toLowerCase()]);\n}\n\nfunction isVisible(element) {\n    return Object(lang[\"toNodes\"])(element).some(element => element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n}\n\nconst selInput = 'input,select,textarea,button';\nfunction isInput(element) {\n    return Object(lang[\"toNodes\"])(element).some(element => selector_matches(element, selInput));\n}\n\nfunction filter_filter(element, selector) {\n    return Object(lang[\"toNodes\"])(element).filter(element => selector_matches(element, selector));\n}\n\nfunction within(element, selector) {\n    return !Object(lang[\"isString\"])(selector)\n        ? element === selector || (Object(lang[\"isDocument\"])(selector)\n            ? selector.documentElement\n            : Object(lang[\"toNode\"])(selector)).contains(Object(lang[\"toNode\"])(element)) // IE 11 document does not implement contains\n        : selector_matches(element, selector) || closest(element, selector);\n}\n\n// CONCATENATED MODULE: ./src/util/event.js\n\n\n\n\nfunction on(...args) {\n\n    let [targets, type, selector, listener, useCapture] = getArgs(args);\n\n    targets = toEventTargets(targets);\n\n    if (selector) {\n        listener = event_delegate(targets, selector, listener);\n    }\n\n    if (listener.length > 1) {\n        listener = event_detail(listener);\n    }\n\n    type.split(' ').forEach(type =>\n        targets.forEach(target =>\n            target.addEventListener(type, listener, useCapture)\n        )\n    );\n    return () => event_off(targets, type, listener, useCapture);\n}\n\nfunction event_off(targets, type, listener, useCapture = false) {\n    targets = toEventTargets(targets);\n    type.split(' ').forEach(type =>\n        targets.forEach(target =>\n            target.removeEventListener(type, listener, useCapture)\n        )\n    );\n}\n\nfunction once(...args) {\n\n    const [element, type, selector, listener, useCapture, condition] = getArgs(args);\n    const off = on(element, type, selector, e => {\n        const result = !condition || condition(e);\n        if (result) {\n            off();\n            listener(e, result);\n        }\n    }, useCapture);\n\n    return off;\n}\n\nfunction trigger(targets, event, detail) {\n    return toEventTargets(targets).reduce((notCanceled, target) =>\n        notCanceled && target.dispatchEvent(createEvent(event, true, true, detail))\n        , true);\n}\n\nfunction createEvent(e, bubbles = true, cancelable = false, detail) {\n    if (Object(lang[\"isString\"])(e)) {\n        const event = document.createEvent('CustomEvent'); // IE 11\n        event.initCustomEvent(e, bubbles, cancelable, detail);\n        e = event;\n    }\n\n    return e;\n}\n\nfunction getArgs(args) {\n    if (Object(lang[\"isFunction\"])(args[2])) {\n        args.splice(2, 0, false);\n    }\n    return args;\n}\n\nfunction event_delegate(delegates, selector, listener) {\n    return e => {\n\n        delegates.forEach(delegate => {\n\n            const current = selector[0] === '>'\n                ? findAll(selector, delegate).reverse().filter(element => within(e.target, element))[0]\n                : closest(e.target, selector);\n\n            if (current) {\n                e.delegate = delegate;\n                e.current = current;\n\n                listener.call(this, e);\n            }\n\n        });\n\n    };\n}\n\nfunction event_detail(listener) {\n    return e => Object(lang[\"isArray\"])(e.detail) ? listener(...[e].concat(e.detail)) : listener(e);\n}\n\nfunction isEventTarget(target) {\n    return target && 'addEventListener' in target;\n}\n\nfunction toEventTarget(target) {\n    return isEventTarget(target) ? target : Object(lang[\"toNode\"])(target);\n}\n\nfunction toEventTargets(target) {\n    return Object(lang[\"isArray\"])(target)\n            ? target.map(toEventTarget).filter(Boolean)\n            : Object(lang[\"isString\"])(target)\n                ? findAll(target)\n                : isEventTarget(target)\n                    ? [target]\n                    : Object(lang[\"toNodes\"])(target);\n}\n\nfunction isTouch(e) {\n    return e.pointerType === 'touch' || e.touches;\n}\n\nfunction getEventPos(e, prop = 'client') {\n    const {touches, changedTouches} = e;\n    const {[`${prop}X`]: x, [`${prop}Y`]: y} = touches && touches[0] || changedTouches && changedTouches[0] || e;\n\n    return {x, y};\n}\n\n// CONCATENATED MODULE: ./src/util/env.js\n/* global DocumentTouch */\n\n\nconst isIE = /msie|trident/i.test(window.navigator.userAgent);\nconst isRtl = attr(document.documentElement, 'dir') === 'rtl';\n\nconst hasTouchEvents = 'ontouchstart' in window;\nconst hasPointerEvents = window.PointerEvent;\nconst hasTouch = hasTouchEvents\n    || window.DocumentTouch && document instanceof DocumentTouch\n    || navigator.maxTouchPoints; // IE >=11\n\nconst pointerDown = hasPointerEvents ? 'pointerdown' : hasTouchEvents ? 'touchstart' : 'mousedown';\nconst pointerMove = hasPointerEvents ? 'pointermove' : hasTouchEvents ? 'touchmove' : 'mousemove';\nconst pointerUp = hasPointerEvents ? 'pointerup' : hasTouchEvents ? 'touchend' : 'mouseup';\nconst pointerEnter = hasPointerEvents ? 'pointerenter' : hasTouchEvents ? '' : 'mouseenter';\nconst pointerLeave = hasPointerEvents ? 'pointerleave' : hasTouchEvents ? '' : 'mouseleave';\nconst pointerCancel = hasPointerEvents ? 'pointercancel' : 'touchcancel';\n\n\n// CONCATENATED MODULE: ./src/util/dom.js\n\n\n\n\nfunction ready(fn) {\n\n    if (document.readyState !== 'loading') {\n        fn();\n        return;\n    }\n\n    const unbind = on(document, 'DOMContentLoaded', function () {\n        unbind();\n        fn();\n    });\n}\n\nfunction dom_index(element, ref) {\n    return ref\n        ? Object(lang[\"toNodes\"])(element).indexOf(Object(lang[\"toNode\"])(ref))\n        : Object(lang[\"toNodes\"])((element = Object(lang[\"toNode\"])(element)) && element.parentNode.children).indexOf(element);\n}\n\nfunction getIndex(i, elements, current = 0, finite = false) {\n\n    elements = Object(lang[\"toNodes\"])(elements);\n\n    const {length} = elements;\n\n    i = Object(lang[\"isNumeric\"])(i)\n        ? Object(lang[\"toNumber\"])(i)\n        : i === 'next'\n            ? current + 1\n            : i === 'previous'\n                ? current - 1\n                : dom_index(elements, i);\n\n    if (finite) {\n        return Object(lang[\"clamp\"])(i, 0, length - 1);\n    }\n\n    i %= length;\n\n    return i < 0 ? i + length : i;\n}\n\nfunction empty(element) {\n    element = $(element);\n    element.innerHTML = '';\n    return element;\n}\n\nfunction dom_html(parent, html) {\n    parent = $(parent);\n    return Object(lang[\"isUndefined\"])(html)\n        ? parent.innerHTML\n        : append(parent.hasChildNodes() ? empty(parent) : parent, html);\n}\n\nfunction prepend(parent, element) {\n\n    parent = $(parent);\n\n    if (!parent.hasChildNodes()) {\n        return append(parent, element);\n    } else {\n        return insertNodes(element, element => parent.insertBefore(element, parent.firstChild));\n    }\n}\n\nfunction append(parent, element) {\n    parent = $(parent);\n    return insertNodes(element, element => parent.appendChild(element));\n}\n\nfunction before(ref, element) {\n    ref = $(ref);\n    return insertNodes(element, element => ref.parentNode.insertBefore(element, ref));\n}\n\nfunction after(ref, element) {\n    ref = $(ref);\n    return insertNodes(element, element => ref.nextSibling\n        ? before(ref.nextSibling, element)\n        : append(ref.parentNode, element)\n    );\n}\n\nfunction insertNodes(element, fn) {\n    element = Object(lang[\"isString\"])(element) ? fragment(element) : element;\n    return element\n        ? 'length' in element\n            ? Object(lang[\"toNodes\"])(element).map(fn)\n            : fn(element)\n        : null;\n}\n\nfunction remove(element) {\n    Object(lang[\"toNodes\"])(element).map(element => element.parentNode && element.parentNode.removeChild(element));\n}\n\nfunction wrapAll(element, structure) {\n\n    structure = Object(lang[\"toNode\"])(before(element, structure));\n\n    while (structure.firstChild) {\n        structure = structure.firstChild;\n    }\n\n    append(structure, element);\n\n    return structure;\n}\n\nfunction wrapInner(element, structure) {\n    return Object(lang[\"toNodes\"])(Object(lang[\"toNodes\"])(element).map(element =>\n        element.hasChildNodes ? wrapAll(Object(lang[\"toNodes\"])(element.childNodes), structure) : append(element, structure)\n    ));\n}\n\nfunction unwrap(element) {\n    Object(lang[\"toNodes\"])(element)\n        .map(element => element.parentNode)\n        .filter((value, index, self) => self.indexOf(value) === index)\n        .forEach(parent => {\n            before(parent, parent.childNodes);\n            remove(parent);\n        });\n}\n\nconst fragmentRe = /^\\s*<(\\w+|!)[^>]*>/;\nconst singleTagRe = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/;\n\nfunction fragment(html) {\n\n    const matches = singleTagRe.exec(html);\n    if (matches) {\n        return document.createElement(matches[1]);\n    }\n\n    const container = document.createElement('div');\n    if (fragmentRe.test(html)) {\n        container.insertAdjacentHTML('beforeend', html.trim());\n    } else {\n        container.textContent = html;\n    }\n\n    return container.childNodes.length > 1 ? Object(lang[\"toNodes\"])(container.childNodes) : container.firstChild;\n\n}\n\nfunction dom_apply(node, fn) {\n\n    if (!node || node.nodeType !== 1) {\n        return;\n    }\n\n    fn(node);\n    node = node.firstElementChild;\n    while (node) {\n        dom_apply(node, fn);\n        node = node.nextElementSibling;\n    }\n}\n\nfunction $(selector, context) {\n    return !Object(lang[\"isString\"])(selector)\n        ? Object(lang[\"toNode\"])(selector)\n        : isHtml(selector)\n            ? Object(lang[\"toNode\"])(fragment(selector))\n            : find(selector, context);\n}\n\nfunction $$(selector, context) {\n    return !Object(lang[\"isString\"])(selector)\n        ? Object(lang[\"toNodes\"])(selector)\n        : isHtml(selector)\n            ? Object(lang[\"toNodes\"])(fragment(selector))\n            : findAll(selector, context);\n}\n\nfunction isHtml(str) {\n    return str[0] === '<' || str.match(/^\\s*</);\n}\n\n\n// CONCATENATED MODULE: ./src/util/class.js\n\n\n\nfunction addClass(element, ...args) {\n    class_apply(element, args, 'add');\n}\n\nfunction removeClass(element, ...args) {\n    class_apply(element, args, 'remove');\n}\n\nfunction removeClasses(element, cls) {\n    attr(element, 'class', value => (value || '').replace(new RegExp(`\\\\b${cls}\\\\b`, 'g'), ''));\n}\n\nfunction replaceClass(element, ...args) {\n    args[0] && removeClass(element, args[0]);\n    args[1] && addClass(element, args[1]);\n}\n\nfunction hasClass(element, cls) {\n    return cls && Object(lang[\"toNodes\"])(element).some(element => element.classList.contains(cls.split(' ')[0]));\n}\n\nfunction toggleClass(element, ...args) {\n\n    if (!args.length) {\n        return;\n    }\n\n    args = class_getArgs(args);\n\n    const force = !Object(lang[\"isString\"])(args[args.length - 1]) ? args.pop() : []; // in iOS 9.3 force === undefined evaluates to false\n\n    args = args.filter(Boolean);\n\n    Object(lang[\"toNodes\"])(element).forEach(({classList}) => {\n        for (let i = 0; i < args.length; i++) {\n            supports.Force\n                ? classList.toggle(...[args[i]].concat(force))\n                : (classList[(!Object(lang[\"isUndefined\"])(force) ? force : !classList.contains(args[i])) ? 'add' : 'remove'](args[i]));\n        }\n    });\n\n}\n\nfunction class_apply(element, args, fn) {\n    args = class_getArgs(args).filter(Boolean);\n\n    args.length && Object(lang[\"toNodes\"])(element).forEach(({classList}) => {\n        supports.Multiple\n            ? classList[fn](...args)\n            : args.forEach(cls => classList[fn](cls));\n    });\n}\n\nfunction class_getArgs(args) {\n    return args.reduce((args, arg) =>\n        args.concat.call(args, Object(lang[\"isString\"])(arg) && Object(lang[\"includes\"])(arg, ' ') ? arg.trim().split(' ') : arg)\n        , []);\n}\n\n// IE 11\nconst supports = {\n\n    get Multiple() {\n        return this.get('_multiple');\n    },\n\n    get Force() {\n        return this.get('_force');\n    },\n\n    get(key) {\n\n        if (!Object(lang[\"hasOwn\"])(this, key)) {\n            const {classList} = document.createElement('_');\n            classList.add('a', 'b');\n            classList.toggle('c', false);\n            this._multiple = classList.contains('b');\n            this._force = !classList.contains('c');\n        }\n\n        return this[key];\n    }\n\n};\n\n// CONCATENATED MODULE: ./src/util/style.js\n\n\n\n\n\nconst cssNumber = {\n   'animation-iteration-count': true,\n   'column-count': true,\n   'fill-opacity': true,\n   'flex-grow': true,\n   'flex-shrink': true,\n   'font-weight': true,\n   'line-height': true,\n   'opacity': true,\n   'order': true,\n   'orphans': true,\n   'stroke-dasharray': true,\n   'stroke-dashoffset': true,\n   'widows': true,\n   'z-index': true,\n   'zoom': true\n};\n\nfunction style_css(element, property, value) {\n\n   return Object(lang[\"toNodes\"])(element).map(element => {\n\n      if (Object(lang[\"isString\"])(property)) {\n\n         property = style_propName(property);\n\n         if (Object(lang[\"isUndefined\"])(value)) {\n            return getStyle(element, property);\n         } else if (!value && !Object(lang[\"isNumber\"])(value)) {\n            element.style.removeProperty(property);\n         } else {\n            element.style[property] = Object(lang[\"isNumeric\"])(value) && !cssNumber[property] ? `${value}px` : value;\n         }\n\n      } else if (Object(lang[\"isArray\"])(property)) {\n\n         const styles = getStyles(element);\n\n         return property.reduce((props, property) => {\n            props[property] = styles[style_propName(property)];\n            return props;\n         }, {});\n\n      } else if (Object(lang[\"isObject\"])(property)) {\n         Object(lang[\"each\"])(property, (value, property) => style_css(element, property, value));\n      }\n\n      return element;\n\n   })[0];\n\n}\n\nfunction getStyles(element, pseudoElt) {\n   element = Object(lang[\"toNode\"])(element);\n   return element.ownerDocument.defaultView.getComputedStyle(element, pseudoElt);\n}\n\nfunction getStyle(element, property, pseudoElt) {\n   return getStyles(element, pseudoElt)[property];\n}\n\nconst vars = {};\n\nfunction getCssVar(name) {\n\n   const docEl = document.documentElement;\n\n   if (!isIE) {\n      return getStyles(docEl).getPropertyValue(`--jdb-${name}`);\n   }\n\n   if (!(name in vars)) {\n\n      /* usage in css: .uk-name:before { content:\"xyz\" } */\n\n      const element = append(docEl, document.createElement('div'));\n\n      addClass(element, `jdb-${name}`);\n\n      vars[name] = getStyle(element, 'content', ':before').replace(/^[\"'](.*)[\"']$/, '$1');\n\n      remove(element);\n\n   }\n\n   return vars[name];\n\n}\n\nconst cssProps = {};\n\nfunction style_propName(name) {\n\n   let ret = cssProps[name];\n   if (!ret) {\n      ret = cssProps[name] = vendorPropName(name) || name;\n   }\n   return ret;\n}\n\nconst cssPrefixes = ['webkit', 'moz', 'ms'];\n\nfunction vendorPropName(name) {\n\n   name = Object(lang[\"hyphenate\"])(name);\n\n   const {style} = document.documentElement;\n\n   if (name in style) {\n      return name;\n   }\n\n   let i = cssPrefixes.length, prefixedName;\n\n   while (i--) {\n      prefixedName = `-${cssPrefixes[i]}-${name}`;\n      if (prefixedName in style) {\n         return prefixedName;\n      }\n   }\n}\n\n// CONCATENATED MODULE: ./src/util/animation.js\n\n\n\n\n\n\n\nfunction animation_transition(element, props, duration = 400, timing = 'linear') {\n\n   return util_promise[\"Promise\"].all(Object(lang[\"toNodes\"])(element).map(element =>\n      new util_promise[\"Promise\"]((resolve, reject) => {\n\n         for (const name in props) {\n            const value = style_css(element, name);\n            if (value === '') {\n               style_css(element, name, value);\n            }\n         }\n\n         const timer = setTimeout(() => trigger(element, 'transitionend'), duration);\n\n         once(element, 'transitionend transitioncanceled', ({type}) => {\n            clearTimeout(timer);\n            removeClass(element, 'jdb-transition');\n            style_css(element, {\n               'transition-property': '',\n               'transition-duration': '',\n               'transition-timing-function': ''\n            });\n            type === 'transitioncanceled' ? reject() : resolve();\n         }, false, ({target}) => element === target);\n\n         addClass(element, 'jdb-transition');\n         style_css(element, Object(lang[\"assign\"])({\n            'transition-property': Object.keys(props).map(style_propName).join(','),\n            'transition-duration': `${duration}ms`,\n            'transition-timing-function': timing\n         }, props));\n\n      })\n   ));\n\n}\n\nconst Transition = {\n\n   start: animation_transition,\n\n   stop(element) {\n      trigger(element, 'transitionend');\n      return util_promise[\"Promise\"].resolve();\n   },\n\n   cancel(element) {\n      trigger(element, 'transitioncanceled');\n   },\n\n   inProgress(element) {\n      return hasClass(element, 'jdb-transition');\n   }\n\n};\n\nconst animationPrefix = 'jdb-animation-';\nconst clsCancelAnimation = 'jdb-cancel-animation';\n\nfunction animation_animate(element, animation, duration = 200, origin, out) {\n\n   return util_promise[\"Promise\"].all(Object(lang[\"toNodes\"])(element).map(element =>\n      new util_promise[\"Promise\"]((resolve, reject) => {\n\n         if (hasClass(element, clsCancelAnimation)) {\n            requestAnimationFrame(() =>\n               util_promise[\"Promise\"].resolve().then(() =>\n                  animation_animate(...arguments).then(resolve, reject)\n               )\n            );\n            return;\n         }\n\n         let cls = `${animation} ${animationPrefix}${out ? 'leave' : 'enter'}`;\n\n         if (Object(lang[\"startsWith\"])(animation, animationPrefix)) {\n\n            if (origin) {\n               cls += ` jdb-transform-origin-${origin}`;\n            }\n\n            if (out) {\n               cls += ` ${animationPrefix}reverse`;\n            }\n\n         }\n\n         reset();\n\n         once(element, 'animationend animationcancel', ({type}) => {\n\n            let hasReset = false;\n\n            if (type === 'animationcancel') {\n               reject();\n               reset();\n            } else {\n               resolve();\n               util_promise[\"Promise\"].resolve().then(() => {\n                  hasReset = true;\n                  reset();\n               });\n            }\n\n            requestAnimationFrame(() => {\n               if (!hasReset) {\n                  addClass(element, clsCancelAnimation);\n\n                  requestAnimationFrame(() => removeClass(element, clsCancelAnimation));\n               }\n            });\n\n         }, false, ({target}) => element === target);\n\n         style_css(element, 'animationDuration', `${duration}ms`);\n         addClass(element, cls);\n\n         function reset() {\n            style_css(element, 'animationDuration', '');\n            removeClasses(element, `${animationPrefix}\\\\S*`);\n         }\n\n      })\n   ));\n\n}\n\nconst animation_inProgress = new RegExp(`${animationPrefix}(enter|leave)`);\nconst Animation = {\n\n   in(element, animation, duration, origin) {\n      return animation_animate(element, animation, duration, origin, false);\n   },\n\n   out(element, animation, duration, origin) {\n      return animation_animate(element, animation, duration, origin, true);\n   },\n\n   inProgress(element) {\n      return animation_inProgress.test(attr(element, 'class'));\n   },\n\n   cancel(element) {\n      trigger(element, 'animationcancel');\n   }\n\n};\n\n// CONCATENATED MODULE: ./src/util/dimensions.js\n\n\n\n\n\nconst dirs = {\n    width: ['x', 'left', 'right'],\n    height: ['y', 'top', 'bottom']\n};\n\nfunction positionAt(element, target, elAttach, targetAttach, elOffset, targetOffset, flip, boundary) {\n\n    elAttach = getPos(elAttach);\n    targetAttach = getPos(targetAttach);\n\n    const flipped = {element: elAttach, target: targetAttach};\n\n    if (!element || !target) {\n        return flipped;\n    }\n\n    const dim = getDimensions(element);\n    const targetDim = getDimensions(target);\n    const position = targetDim;\n\n    moveTo(position, elAttach, dim, -1);\n    moveTo(position, targetAttach, targetDim, 1);\n\n    elOffset = getOffsets(elOffset, dim.width, dim.height);\n    targetOffset = getOffsets(targetOffset, targetDim.width, targetDim.height);\n\n    elOffset['x'] += targetOffset['x'];\n    elOffset['y'] += targetOffset['y'];\n\n    position.left += elOffset['x'];\n    position.top += elOffset['y'];\n\n    if (flip) {\n\n        const boundaries = [getDimensions(getWindow(element))];\n\n        if (boundary) {\n            boundaries.unshift(getDimensions(boundary));\n        }\n\n        Object(lang[\"each\"])(dirs, ([dir, align, alignFlip], prop) => {\n\n            if (!(flip === true || Object(lang[\"includes\"])(flip, dir))) {\n                return;\n            }\n\n            boundaries.some(boundary => {\n\n                const elemOffset = elAttach[dir] === align\n                    ? -dim[prop]\n                    : elAttach[dir] === alignFlip\n                        ? dim[prop]\n                        : 0;\n\n                const targetOffset = targetAttach[dir] === align\n                    ? targetDim[prop]\n                    : targetAttach[dir] === alignFlip\n                        ? -targetDim[prop]\n                        : 0;\n\n                if (position[align] < boundary[align] || position[align] + dim[prop] > boundary[alignFlip]) {\n\n                    const centerOffset = dim[prop] / 2;\n                    const centerTargetOffset = targetAttach[dir] === 'center' ? -targetDim[prop] / 2 : 0;\n\n                    return elAttach[dir] === 'center' && (\n                        apply(centerOffset, centerTargetOffset)\n                        || apply(-centerOffset, -centerTargetOffset)\n                    ) || apply(elemOffset, targetOffset);\n\n                }\n\n                function apply(elemOffset, targetOffset) {\n\n                    const newVal = position[align] + elemOffset + targetOffset - elOffset[dir] * 2;\n\n                    if (newVal >= boundary[align] && newVal + dim[prop] <= boundary[alignFlip]) {\n                        position[align] = newVal;\n\n                        ['element', 'target'].forEach(el => {\n                            flipped[el][dir] = !elemOffset\n                                ? flipped[el][dir]\n                                : flipped[el][dir] === dirs[prop][1]\n                                    ? dirs[prop][2]\n                                    : dirs[prop][1];\n                        });\n\n                        return true;\n                    }\n\n                }\n\n            });\n\n        });\n    }\n\n    dimensions_offset(element, position);\n\n    return flipped;\n}\n\nfunction dimensions_offset(element, coordinates) {\n\n    element = Object(lang[\"toNode\"])(element);\n\n    if (coordinates) {\n\n        const currentOffset = dimensions_offset(element);\n        const pos = style_css(element, 'position');\n\n        ['left', 'top'].forEach(prop => {\n            if (prop in coordinates) {\n                const value = style_css(element, prop);\n                style_css(element, prop, coordinates[prop] - currentOffset[prop]\n                    + Object(lang[\"toFloat\"])(pos === 'absolute' && value === 'auto'\n                        ? dimensions_position(element)[prop]\n                        : value)\n                );\n            }\n        });\n\n        return;\n    }\n\n    return getDimensions(element);\n}\n\nfunction getDimensions(element) {\n\n    element = Object(lang[\"toNode\"])(element);\n\n    const {pageYOffset: top, pageXOffset: left} = getWindow(element);\n\n    if (Object(lang[\"isWindow\"])(element)) {\n\n        const height = element.innerHeight;\n        const width = element.innerWidth;\n\n        return {\n            top,\n            left,\n            height,\n            width,\n            bottom: top + height,\n            right: left + width\n        };\n    }\n\n    let style, hidden;\n\n    if (!isVisible(element) && style_css(element, 'display') === 'none') {\n\n        style = attr(element, 'style');\n        hidden = attr(element, 'hidden');\n\n        attr(element, {\n            style: `${style || ''};display:block !important;`,\n            hidden: null\n        });\n    }\n\n    const rect = element.getBoundingClientRect();\n\n    if (!Object(lang[\"isUndefined\"])(style)) {\n        attr(element, {style, hidden});\n    }\n\n    return {\n        height: rect.height,\n        width: rect.width,\n        top: rect.top + top,\n        left: rect.left + left,\n        bottom: rect.bottom + top,\n        right: rect.right + left\n    };\n}\n\nfunction dimensions_position(element) {\n    element = Object(lang[\"toNode\"])(element);\n\n    const parent = element.offsetParent || getDocEl(element);\n    const parentOffset = dimensions_offset(parent);\n    const {top, left} = ['top', 'left'].reduce((props, prop) => {\n        const propName = Object(lang[\"ucfirst\"])(prop);\n        props[prop] -= parentOffset[prop]\n            + Object(lang[\"toFloat\"])(style_css(element, `margin${propName}`))\n            + Object(lang[\"toFloat\"])(style_css(parent, `border${propName}Width`));\n        return props;\n    }, dimensions_offset(element));\n\n    return {top, left};\n}\n\nconst dimensions_height = dimension('height');\nconst dimensions_width = dimension('width');\n\nfunction dimension(prop) {\n    const propName = Object(lang[\"ucfirst\"])(prop);\n    return (element, value) => {\n\n        element = Object(lang[\"toNode\"])(element);\n\n        if (Object(lang[\"isUndefined\"])(value)) {\n\n            if (Object(lang[\"isWindow\"])(element)) {\n                return element[`inner${propName}`];\n            }\n\n            if (Object(lang[\"isDocument\"])(element)) {\n                const doc = element.documentElement;\n                return Math.max(doc[`offset${propName}`], doc[`scroll${propName}`]);\n            }\n\n            value = style_css(element, prop);\n            value = value === 'auto' ? element[`offset${propName}`] : Object(lang[\"toFloat\"])(value) || 0;\n\n            return value - boxModelAdjust(prop, element);\n\n        } else {\n\n            style_css(element, prop, !value && value !== 0\n                ? ''\n                : +value + boxModelAdjust(prop, element) + 'px'\n            );\n\n        }\n\n    };\n}\n\nfunction boxModelAdjust(prop, element, sizing = 'border-box') {\n    return style_css(element, 'boxSizing') === sizing\n        ? dirs[prop].slice(1).map(lang[\"ucfirst\"]).reduce((value, prop) =>\n            value\n            + Object(lang[\"toFloat\"])(style_css(element, `padding${prop}`))\n            + Object(lang[\"toFloat\"])(style_css(element, `border${prop}Width`))\n            , 0)\n        : 0;\n}\n\nfunction moveTo(position, attach, dim, factor) {\n    Object(lang[\"each\"])(dirs, ([dir, align, alignFlip], prop) => {\n        if (attach[dir] === alignFlip) {\n            position[align] += dim[prop] * factor;\n        } else if (attach[dir] === 'center') {\n            position[align] += dim[prop] * factor / 2;\n        }\n    });\n}\n\nfunction getPos(pos) {\n\n    const x = /left|center|right/;\n    const y = /top|center|bottom/;\n\n    pos = (pos || '').split(' ');\n\n    if (pos.length === 1) {\n        pos = x.test(pos[0])\n            ? pos.concat(['center'])\n            : y.test(pos[0])\n                ? ['center'].concat(pos)\n                : ['center', 'center'];\n    }\n\n    return {\n        x: x.test(pos[0]) ? pos[0] : 'center',\n        y: y.test(pos[1]) ? pos[1] : 'center'\n    };\n}\n\nfunction getOffsets(offsets, width, height) {\n\n    const [x, y] = (offsets || '').split(' ');\n\n    return {\n        x: x ? Object(lang[\"toFloat\"])(x) * (Object(lang[\"endsWith\"])(x, '%') ? width / 100 : 1) : 0,\n        y: y ? Object(lang[\"toFloat\"])(y) * (Object(lang[\"endsWith\"])(y, '%') ? height / 100 : 1) : 0\n    };\n}\n\nfunction flipPosition(pos) {\n    switch (pos) {\n        case 'left':\n            return 'right';\n        case 'right':\n            return 'left';\n        case 'top':\n            return 'bottom';\n        case 'bottom':\n            return 'top';\n        default:\n            return pos;\n    }\n}\n\nfunction isInView(element, topOffset = 0, leftOffset = 0) {\n\n    if (!isVisible(element)) {\n        return false;\n    }\n\n    element = Object(lang[\"toNode\"])(element);\n\n    const win = getWindow(element);\n    const client = element.getBoundingClientRect();\n    const bounding = {\n        top: -topOffset,\n        left: -leftOffset,\n        bottom: topOffset + dimensions_height(win),\n        right: leftOffset + dimensions_width(win)\n    };\n\n    return Object(lang[\"intersectRect\"])(client, bounding) || Object(lang[\"pointInRect\"])({x: client.left, y: client.top}, bounding);\n\n}\n\nfunction scrolledOver(element, heightOffset = 0) {\n\n    if (!isVisible(element)) {\n        return 0;\n    }\n\n    element = Object(lang[\"toNode\"])(element);\n\n    const win = getWindow(element);\n    const doc = getDocument(element);\n    const elHeight = element.offsetHeight + heightOffset;\n    const [top] = offsetPosition(element);\n    const vp = dimensions_height(win);\n    const vh = vp + Math.min(0, top - vp);\n    const diff = Math.max(0, vp - (dimensions_height(doc) + heightOffset - (top + elHeight)));\n\n    return Object(lang[\"clamp\"])(((vh + win.pageYOffset - top) / ((vh + (elHeight - (diff < vp ? diff : 0))) / 100)) / 100);\n}\n\nfunction scrollTop(element, top) {\n    element = Object(lang[\"toNode\"])(element);\n\n    if (Object(lang[\"isWindow\"])(element) || Object(lang[\"isDocument\"])(element)) {\n        const {scrollTo, pageXOffset} = getWindow(element);\n        scrollTo(pageXOffset, top);\n    } else {\n        element.scrollTop = top;\n    }\n}\n\nfunction offsetPosition(element) {\n    const offset = [0, 0];\n\n    do {\n\n        offset[0] += element.offsetTop;\n        offset[1] += element.offsetLeft;\n\n        if (style_css(element, 'position') === 'fixed') {\n            const win = getWindow(element);\n            offset[0] += win.pageYOffset;\n            offset[1] += win.pageXOffset;\n            return offset;\n        }\n\n    } while ((element = element.offsetParent));\n\n    return offset;\n}\n\nfunction toPx(value, property = 'width', element = window) {\n    return Object(lang[\"isNumeric\"])(value)\n        ? +value\n        : Object(lang[\"endsWith\"])(value, 'vh')\n            ? dimensions_percent(dimensions_height(getWindow(element)), value)\n            : Object(lang[\"endsWith\"])(value, 'vw')\n                ? dimensions_percent(dimensions_width(getWindow(element)), value)\n                : Object(lang[\"endsWith\"])(value, '%')\n                    ? dimensions_percent(getDimensions(element)[property], value)\n                    : Object(lang[\"toFloat\"])(value);\n}\n\nfunction dimensions_percent(base, value) {\n    return base * Object(lang[\"toFloat\"])(value) / 100;\n}\n\nfunction getWindow(element) {\n    return Object(lang[\"isWindow\"])(element) ? element : getDocument(element).defaultView;\n}\n\nfunction getDocument(element) {\n    return Object(lang[\"toNode\"])(element).ownerDocument;\n}\n\nfunction getDocEl(element) {\n    return getDocument(element).documentElement;\n}\n\n// CONCATENATED MODULE: ./src/util/fastdom.js\n/*\n    Based on:\n    Copyright (c) 2016 Wilson Page wilsonpage@me.com\n    https://github.com/wilsonpage/fastdom\n*/\n\nconst fastdom = {\n\n    reads: [],\n    writes: [],\n\n    read(task) {\n        this.reads.push(task);\n        scheduleFlush();\n        return task;\n    },\n\n    write(task) {\n        this.writes.push(task);\n        scheduleFlush();\n        return task;\n    },\n\n    clear(task) {\n        return fastdom_remove(this.reads, task) || fastdom_remove(this.writes, task);\n    },\n\n    flush() {\n\n        runTasks(this.reads);\n        runTasks(this.writes.splice(0, this.writes.length));\n\n        this.scheduled = false;\n\n        if (this.reads.length || this.writes.length) {\n            scheduleFlush();\n        }\n\n    }\n\n};\n\nfunction scheduleFlush() {\n    if (!fastdom.scheduled) {\n        fastdom.scheduled = true;\n        requestAnimationFrame(fastdom.flush.bind(fastdom));\n    }\n}\n\nfunction runTasks(tasks) {\n    let task;\n    while ((task = tasks.shift())) {\n        task();\n    }\n}\n\nfunction fastdom_remove(array, item) {\n    const index = array.indexOf(item);\n    return !!~index && !!array.splice(index, 1);\n}\n\n// CONCATENATED MODULE: ./src/util/options.js\n\n\nconst strats = {};\n\nstrats.events =\nstrats.created =\nstrats.beforeConnect =\nstrats.connected =\nstrats.beforeDisconnect =\nstrats.disconnected =\nstrats.destroy = concatStrat;\n\n// args strategy\nstrats.args = function (parentVal, childVal) {\n    return concatStrat(childVal || parentVal);\n};\n\n// update strategy\nstrats.update = function (parentVal, childVal) {\n    return Object(lang[\"sortBy\"])(concatStrat(parentVal, Object(lang[\"isFunction\"])(childVal) ? {read: childVal} : childVal), 'order');\n};\n\n// property strategy\nstrats.props = function (parentVal, childVal) {\n\n    if (Object(lang[\"isArray\"])(childVal)) {\n        childVal = childVal.reduce((value, key) => {\n            value[key] = String;\n            return value;\n        }, {});\n    }\n\n    return strats.methods(parentVal, childVal);\n};\n\n// extend strategy\nstrats.computed =\nstrats.methods = function (parentVal, childVal) {\n    return childVal\n        ? parentVal\n            ? Object(lang[\"assign\"])({}, parentVal, childVal)\n            : childVal\n        : parentVal;\n};\n\n// data strategy\nstrats.data = function (parentVal, childVal, vm) {\n\n    if (!vm) {\n\n        if (!childVal) {\n            return parentVal;\n        }\n\n        if (!parentVal) {\n            return childVal;\n        }\n\n        return function (vm) {\n            return mergeFnData(parentVal, childVal, vm);\n        };\n\n    }\n\n    return mergeFnData(parentVal, childVal, vm);\n};\n\nfunction mergeFnData(parentVal, childVal, vm) {\n    return strats.computed(\n        Object(lang[\"isFunction\"])(parentVal)\n            ? parentVal.call(vm, vm)\n            : parentVal,\n        Object(lang[\"isFunction\"])(childVal)\n            ? childVal.call(vm, vm)\n            : childVal\n    );\n}\n\n// concat strategy\nfunction concatStrat(parentVal, childVal) {\n\n    parentVal = parentVal && !Object(lang[\"isArray\"])(parentVal) ? [parentVal] : parentVal;\n\n    return childVal\n        ? parentVal\n            ? parentVal.concat(childVal)\n            : Object(lang[\"isArray\"])(childVal)\n                ? childVal\n                : [childVal]\n        : parentVal;\n}\n\n// default strategy\nfunction defaultStrat(parentVal, childVal) {\n    return Object(lang[\"isUndefined\"])(childVal) ? parentVal : childVal;\n}\n\nfunction mergeOptions(parent, child, vm) {\n\n    const options = {};\n\n    if (Object(lang[\"isFunction\"])(child)) {\n        child = child.options;\n    }\n\n    if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n    }\n\n    if (child.mixins) {\n        for (let i = 0, l = child.mixins.length; i < l; i++) {\n            parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n    }\n\n    for (const key in parent) {\n        mergeKey(key);\n    }\n\n    for (const key in child) {\n        if (!Object(lang[\"hasOwn\"])(parent, key)) {\n            mergeKey(key);\n        }\n    }\n\n    function mergeKey(key) {\n        options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);\n    }\n\n    return options;\n}\n\nfunction parseOptions(options, args = []) {\n\n    try {\n\n        return !options\n            ? {}\n            : Object(lang[\"startsWith\"])(options, '{')\n                ? JSON.parse(options)\n                : args.length && !Object(lang[\"includes\"])(options, ':')\n                    ? ({[args[0]]: options})\n                    : options.split(';').reduce((options, option) => {\n                        const [key, value] = option.split(/:(.*)/);\n                        if (key && !Object(lang[\"isUndefined\"])(value)) {\n                            options[key.trim()] = value.trim();\n                        }\n                        return options;\n                    }, {});\n\n    } catch (e) {\n        return {};\n    }\n\n}\n\n// CONCATENATED MODULE: ./src/util/index.js\n//export * from './ajax';\n\n\n\n\n\n\n\n\n\n\n//export * from './mouse';\n\n//export * from './player';\n\n//export * from './intersection';\n\n\n\n// CONCATENATED MODULE: ./src/api/component.js\n\n\n/* harmony default export */ var api_component = (function (UIkit) {\n\n   const DATA = UIkit.data;\n\n   const components = {};\n\n   UIkit.component = function (name, options) {\n\n      if (!options) {\n\n         if (Object(lang[\"isPlainObject\"])(components[name])) {\n            components[name] = UIkit.extend(components[name]);\n         }\n\n         return components[name];\n\n      }\n\n      UIkit[name] = function (element, data) {\n\n         const component = UIkit.component(name);\n\n         if (Object(lang[\"isPlainObject\"])(element)) {\n            return new component({data: element});\n         }\n\n         if (component.options.functional) {\n            return new component({data: [...arguments]});\n         }\n\n         return element && element.nodeType ? init(element) : $$(element).map(init)[0];\n\n         function init(element) {\n\n            const instance = UIkit.getComponent(element, name);\n\n            if (instance) {\n               if (!data) {\n                  return instance;\n               } else {\n                  instance.$destroy();\n               }\n            }\n\n            return new component({el: element, data});\n\n         }\n\n      };\n\n      const opt = Object(lang[\"isPlainObject\"])(options) ? Object(lang[\"assign\"])({}, options) : options.options;\n\n      opt.name = name;\n\n      if (opt.install) {\n         opt.install(UIkit, opt, name);\n      }\n\n      if (UIkit._initialized && !opt.functional) {\n         const id = Object(lang[\"hyphenate\"])(name);\n         fastdom.read(() => UIkit[name](`[jdb-${id}],[data-jdb-${id}]`));\n      }\n\n      return components[name] = Object(lang[\"isPlainObject\"])(options) ? opt : options;\n   };\n\n   UIkit.getComponents = element => element && element[DATA] || {};\n   UIkit.getComponent = (element, name) => UIkit.getComponents(element)[name];\n\n   UIkit.connect = node => {\n\n      if (node[DATA]) {\n         for (const name in node[DATA]) {\n            node[DATA][name]._callConnected();\n         }\n      }\n\n      for (let i = 0; i < node.attributes.length; i++) {\n\n         const name = getComponentName(node.attributes[i].name);\n\n         if (name && name in components) {\n            UIkit[name](node);\n         }\n\n      }\n\n   };\n\n   UIkit.disconnect = node => {\n      for (const name in node[DATA]) {\n         node[DATA][name]._callDisconnected();\n      }\n   };\n\n});\n\nfunction getComponentName(attribute) {\n   return Object(lang[\"startsWith\"])(attribute, 'jdb-') || Object(lang[\"startsWith\"])(attribute, 'data-jdb-')\n           ? Object(lang[\"camelize\"])(attribute.replace('data-jdb-', '').replace('jdb-', ''))\n           : false;\n}\n\n// CONCATENATED MODULE: ./src/api/boot.js\n\n\n\n/* harmony default export */ var boot = (function (UIkit) {\n\n   const {connect, disconnect} = UIkit;\n\n   if (!('MutationObserver' in window)) {\n      return;\n   }\n\n   if (document.body) {\n\n      init();\n\n   } else {\n\n      (new MutationObserver(function () {\n\n         if (document.body) {\n            this.disconnect();\n            init();\n         }\n\n      })).observe(document, {childList: true, subtree: true});\n\n   }\n\n   function init() {\n\n      apply(document.body, connect);\n\n      fastdom.flush();\n\n      (new MutationObserver(mutations => mutations.forEach(applyMutation))).observe(document, {\n         childList: true,\n         subtree: true,\n         characterData: true,\n         attributes: true\n      });\n\n      UIkit._initialized = true;\n   }\n\n   function applyMutation(mutation) {\n\n      const {target, type} = mutation;\n\n      const update = type !== 'attributes'\n              ? applyChildList(mutation)\n              : applyAttribute(mutation);\n\n      update && UIkit.update(target);\n\n   }\n\n   function applyAttribute( {target, attributeName}) {\n\n      if (attributeName === 'href') {\n         return true;\n      }\n\n      const name = getComponentName(attributeName);\n      \n      if (!name || !(name in UIkit)) {\n         return;\n      }\n\n      if (hasAttr(target, attributeName)) {\n         UIkit[name](target);\n         return true;\n      }\n\n      const component = UIkit.getComponent(target, name);\n\n      if (component) {\n         component.$destroy();\n         return true;\n   }\n\n   }\n\n   function applyChildList( {addedNodes, removedNodes}) {\n\n      for (let i = 0; i < addedNodes.length; i++) {\n         apply(addedNodes[i], connect);\n      }\n\n      for (let i = 0; i < removedNodes.length; i++) {\n         apply(removedNodes[i], disconnect);\n      }\n\n      return true;\n   }\n\n   function apply(node, fn) {\n\n      if (node.nodeType !== 1 || hasAttr(node, 'jdb-no-boot')) {\n         return;\n      }\n\n      fn(node);\n      node = node.firstElementChild;\n      while (node) {\n         const next = node.nextElementSibling;\n         apply(node, fn);\n         node = next;\n      }\n   }\n\n});\n\n// CONCATENATED MODULE: ./src/api/global.js\n\n\n/* harmony default export */ var global = (function (UIkit) {\n\n    const DATA = UIkit.data;\n\n    UIkit.use = function (plugin) {\n\n        if (plugin.installed) {\n            return;\n        }\n\n        plugin.call(null, this);\n        plugin.installed = true;\n\n        return this;\n    };\n\n    UIkit.mixin = function (mixin, component) {\n        component = (Object(lang[\"isString\"])(component) ? UIkit.component(component) : component) || this;\n        component.options = mergeOptions(component.options, mixin);\n    };\n\n    UIkit.extend = function (options) {\n\n        options = options || {};\n\n        const Super = this;\n        const Sub = function UIkitComponent(options) {\n            this._init(options);\n        };\n\n        Sub.prototype = Object.create(Super.prototype);\n        Sub.prototype.constructor = Sub;\n        Sub.options = mergeOptions(Super.options, options);\n\n        Sub.super = Super;\n        Sub.extend = Super.extend;\n\n        return Sub;\n    };\n\n    UIkit.update = function (element, e) {\n\n        element = element ? Object(lang[\"toNode\"])(element) : document.body;\n\n        path(element, element => update(element[DATA], e));\n        dom_apply(element, element => update(element[DATA], e));\n\n    };\n\n    let container;\n    Object.defineProperty(UIkit, 'container', {\n\n        get() {\n            return container || document.body;\n        },\n\n        set(element) {\n            container = $(element);\n        }\n\n    });\n\n    function update(data, e) {\n\n        if (!data) {\n            return;\n        }\n\n        for (const name in data) {\n            if (data[name]._connected) {\n                data[name]._callUpdate(e);\n            }\n        }\n\n    }\n\n    function path(node, fn) {\n        if (node && node !== document.body && node.parentNode) {\n            path(node.parentNode, fn);\n            fn(node.parentNode);\n        }\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/api/hooks.js\n\n\n/* harmony default export */ var hooks = (function (UIkit) {\n\n    UIkit.prototype._callHook = function (hook) {\n\n        const handlers = this.$options[hook];\n\n        if (handlers) {\n            handlers.forEach(handler => handler.call(this));\n        }\n    };\n\n    UIkit.prototype._callConnected = function () {\n\n        if (this._connected) {\n            return;\n        }\n\n        this._data = {};\n        this._computeds = {};\n        this._initProps();\n\n        this._callHook('beforeConnect');\n        this._connected = true;\n\n        this._initEvents();\n        this._initObserver();\n\n        this._callHook('connected');\n        this._callUpdate();\n    };\n\n    UIkit.prototype._callDisconnected = function () {\n\n        if (!this._connected) {\n            return;\n        }\n\n        this._callHook('beforeDisconnect');\n\n        if (this._observer) {\n            this._observer.disconnect();\n            this._observer = null;\n        }\n\n        this._unbindEvents();\n        this._callHook('disconnected');\n\n        this._connected = false;\n\n    };\n\n    UIkit.prototype._callUpdate = function (e = 'update') {\n\n        const type = e.type || e;\n\n        if (Object(lang[\"includes\"])(['update', 'resize'], type)) {\n            this._callWatches();\n        }\n\n        const updates = this.$options.update;\n        const {reads, writes} = this._frames;\n\n        if (!updates) {\n            return;\n        }\n\n        updates.forEach(({read, write, events}, i) => {\n\n            if (type !== 'update' && !Object(lang[\"includes\"])(events, type)) {\n                return;\n            }\n\n            if (read && !Object(lang[\"includes\"])(fastdom.reads, reads[i])) {\n                reads[i] = fastdom.read(() => {\n\n                    const result = this._connected && read.call(this, this._data, type);\n\n                    if (result === false && write) {\n                        fastdom.clear(writes[i]);\n                    } else if (Object(lang[\"isPlainObject\"])(result)) {\n                        Object(lang[\"assign\"])(this._data, result);\n                    }\n                });\n            }\n\n            if (write && !Object(lang[\"includes\"])(fastdom.writes, writes[i])) {\n                writes[i] = fastdom.write(() => this._connected && write.call(this, this._data, type));\n            }\n\n        });\n\n    };\n\n});\n\n// CONCATENATED MODULE: ./src/api/state.js\n\n\n/* harmony default export */ var api_state = (function (UIkit) {\n\n    let uid = 0;\n\n    UIkit.prototype._init = function (options) {\n\n        options = options || {};\n        options.data = normalizeData(options, this.constructor.options);\n\n        this.$options = mergeOptions(this.constructor.options, options, this);\n        this.$el = null;\n        this.$props = {};\n\n        this._frames = {reads: {}, writes: {}};\n        this._events = [];\n\n        this._uid = uid++;\n        this._initData();\n        this._initMethods();\n        this._initComputeds();\n        this._callHook('created');\n\n        if (options.el) {\n            this.$mount(options.el);\n        }\n    };\n\n    UIkit.prototype._initData = function () {\n\n        const {data = {}} = this.$options;\n\n        for (const key in data) {\n            this.$props[key] = this[key] = data[key];\n        }\n    };\n\n    UIkit.prototype._initMethods = function () {\n\n        const {methods} = this.$options;\n\n        if (methods) {\n            for (const key in methods) {\n                this[key] = Object(lang[\"bind\"])(methods[key], this);\n            }\n        }\n    };\n\n    UIkit.prototype._initComputeds = function () {\n\n        const {computed} = this.$options;\n\n        this._computeds = {};\n\n        if (computed) {\n            for (const key in computed) {\n                registerComputed(this, key, computed[key]);\n            }\n        }\n    };\n\n    UIkit.prototype._callWatches = function () {\n\n        const {$options: {computed}, _computeds} = this;\n\n        for (const key in _computeds) {\n\n            const value = _computeds[key];\n            delete _computeds[key];\n\n            if (computed[key].watch && !Object(lang[\"isEqual\"])(value, this[key])) {\n                computed[key].watch.call(this, this[key], value);\n            }\n\n        }\n\n    };\n\n    UIkit.prototype._initProps = function (props) {\n\n        let key;\n\n        props = props || getProps(this.$options, this.$name);\n\n        for (key in props) {\n            if (!Object(lang[\"isUndefined\"])(props[key])) {\n                this.$props[key] = props[key];\n            }\n        }\n\n        const exclude = [this.$options.computed, this.$options.methods];\n        for (key in this.$props) {\n            if (key in props && notIn(exclude, key)) {\n                this[key] = this.$props[key];\n            }\n        }\n    };\n\n    UIkit.prototype._initEvents = function () {\n\n        const {events} = this.$options;\n\n        if (events) {\n\n            events.forEach(event => {\n\n                if (!Object(lang[\"hasOwn\"])(event, 'handler')) {\n                    for (const key in event) {\n                        registerEvent(this, event[key], key);\n                    }\n                } else {\n                    registerEvent(this, event);\n                }\n\n            });\n        }\n    };\n\n    UIkit.prototype._unbindEvents = function () {\n        this._events.forEach(unbind => unbind());\n        this._events = [];\n    };\n\n    UIkit.prototype._initObserver = function () {\n\n        let {attrs, props, el} = this.$options;\n        if (this._observer || !props || attrs === false) {\n            return;\n        }\n\n        attrs = Object(lang[\"isArray\"])(attrs) ? attrs : Object.keys(props);\n\n        this._observer = new MutationObserver(() => {\n\n            const data = getProps(this.$options, this.$name);\n            if (attrs.some(key => !Object(lang[\"isUndefined\"])(data[key]) && data[key] !== this.$props[key])) {\n                this.$reset();\n            }\n\n        });\n\n        const filter = attrs.map(key => Object(lang[\"hyphenate\"])(key)).concat(this.$name);\n\n        this._observer.observe(el, {\n            attributes: true,\n            attributeFilter: filter.concat(filter.map(key => `data-${key}`))\n        });\n    };\n\n    function getProps(opts, name) {\n\n        const data = {};\n        const {args = [], props = {}, el} = opts;\n\n        if (!props) {\n            return data;\n        }\n\n        for (const key in props) {\n            const prop = Object(lang[\"hyphenate\"])(key);\n            let value = attr_data(el, prop);\n\n            if (!Object(lang[\"isUndefined\"])(value)) {\n\n                value = props[key] === Boolean && value === ''\n                    ? true\n                    : coerce(props[key], value);\n\n                if (prop === 'target' && (!value || Object(lang[\"startsWith\"])(value, '_'))) {\n                    continue;\n                }\n\n                data[key] = value;\n            }\n        }\n\n        const options = parseOptions(attr_data(el, name), args);\n\n        for (const key in options) {\n            const prop = Object(lang[\"camelize\"])(key);\n            if (props[prop] !== undefined) {\n                data[prop] = coerce(props[prop], options[key]);\n            }\n        }\n\n        return data;\n    }\n\n    function registerComputed(component, key, cb) {\n        Object.defineProperty(component, key, {\n\n            enumerable: true,\n\n            get() {\n\n                const {_computeds, $props, $el} = component;\n\n                if (!Object(lang[\"hasOwn\"])(_computeds, key)) {\n                    _computeds[key] = (cb.get || cb).call(component, $props, $el);\n                }\n\n                return _computeds[key];\n            },\n\n            set(value) {\n\n                const {_computeds} = component;\n\n                _computeds[key] = cb.set ? cb.set.call(component, value) : value;\n\n                if (Object(lang[\"isUndefined\"])(_computeds[key])) {\n                    delete _computeds[key];\n                }\n            }\n\n        });\n    }\n\n    function registerEvent(component, event, key) {\n\n        if (!Object(lang[\"isPlainObject\"])(event)) {\n            event = ({name: key, handler: event});\n        }\n\n        let {name, el, handler, capture, passive, delegate, filter, self} = event;\n        el = Object(lang[\"isFunction\"])(el)\n            ? el.call(component)\n            : el || component.$el;\n\n        if (Object(lang[\"isArray\"])(el)) {\n            el.forEach(el => registerEvent(component, Object(lang[\"assign\"])({}, event, {el}), key));\n            return;\n        }\n\n        if (!el || filter && !filter.call(component)) {\n            return;\n        }\n\n        handler = detail(Object(lang[\"isString\"])(handler) ? component[handler] : Object(lang[\"bind\"])(handler, component));\n\n        if (self) {\n            handler = selfFilter(handler);\n        }\n\n        component._events.push(\n            on(\n                el,\n                name,\n                !delegate\n                    ? null\n                    : Object(lang[\"isString\"])(delegate)\n                        ? delegate\n                        : delegate.call(component),\n                handler,\n                Object(lang[\"isBoolean\"])(passive)\n                    ? {passive, capture}\n                    : capture\n            )\n        );\n\n    }\n\n    function selfFilter(handler) {\n        return function selfHandler(e) {\n            if (e.target === e.currentTarget || e.target === e.current) {\n                return handler.call(null, e);\n            }\n        };\n    }\n\n    function notIn(options, key) {\n        return options.every(arr => !arr || !Object(lang[\"hasOwn\"])(arr, key));\n    }\n\n    function detail(listener) {\n        return e => Object(lang[\"isArray\"])(e.detail) ? listener(...[e].concat(e.detail)) : listener(e);\n    }\n\n    function coerce(type, value) {\n\n        if (type === Boolean) {\n            return Object(lang[\"toBoolean\"])(value);\n        } else if (type === Number) {\n            return Object(lang[\"toNumber\"])(value);\n        } else if (type === 'list') {\n            return Object(lang[\"toList\"])(value);\n        }\n\n        return type ? type(value) : value;\n    }\n\n    function normalizeData({data, el}, {args, props = {}}) {\n        data = Object(lang[\"isArray\"])(data)\n            ? !Object(lang[\"isEmpty\"])(args)\n                ? data.slice(0, args.length).reduce((data, value, index) => {\n                    if (Object(lang[\"isPlainObject\"])(value)) {\n                        Object(lang[\"assign\"])(data, value);\n                    } else {\n                        data[args[index]] = value;\n                    }\n                    return data;\n                }, {})\n                : undefined\n            : data;\n\n        if (data) {\n            for (const key in data) {\n                if (Object(lang[\"isUndefined\"])(data[key])) {\n                    delete data[key];\n                } else {\n                    data[key] = props[key] ? coerce(props[key], data[key], el) : data[key];\n                }\n            }\n        }\n\n        return data;\n    }\n});\n\n// CONCATENATED MODULE: ./src/api/instance.js\n\n\n/* harmony default export */ var instance = (function (UIkit) {\n\n    const DATA = UIkit.data;\n\n    UIkit.prototype.$mount = function (el) {\n\n        const {name} = this.$options;\n\n        if (!el[DATA]) {\n            el[DATA] = {};\n        }\n\n        if (el[DATA][name]) {\n            return;\n        }\n\n        el[DATA][name] = this;\n\n        this.$el = this.$options.el = this.$options.el || el;\n\n        if (within(el, document)) {\n            this._callConnected();\n        }\n    };\n\n    UIkit.prototype.$emit = function (e) {\n        this._callUpdate(e);\n    };\n\n    UIkit.prototype.$reset = function () {\n        this._callDisconnected();\n        this._callConnected();\n    };\n\n    UIkit.prototype.$destroy = function (removeEl = false) {\n\n        const {el, name} = this.$options;\n\n        if (el) {\n            this._callDisconnected();\n        }\n\n        this._callHook('destroy');\n\n        if (!el || !el[DATA]) {\n            return;\n        }\n\n        delete el[DATA][name];\n\n        if (!Object(lang[\"isEmpty\"])(el[DATA])) {\n            delete el[DATA];\n        }\n\n        if (removeEl) {\n            remove(this.$el);\n        }\n    };\n\n    UIkit.prototype.$create = function (component, element, data) {\n        return UIkit[component](element, data);\n    };\n\n    UIkit.prototype.$update = UIkit.update;\n    UIkit.prototype.$getComponent = UIkit.getComponent;\n\n    const names = {};\n    Object.defineProperties(UIkit.prototype, {\n\n        $container: Object.getOwnPropertyDescriptor(UIkit, 'container'),\n\n        $name: {\n\n            get() {\n                const {name} = this.$options;\n\n                if (!names[name]) {\n                    names[name] = UIkit.prefix + Object(lang[\"hyphenate\"])(name);\n                }\n\n                return names[name];\n            }\n\n        }\n\n    });\n\n});\n\n// CONCATENATED MODULE: ./src/api/index.js\n\n\n\n\n\n\n\nconst api_UIkit = function (options) {\n    this._init(options);\n};\n\napi_UIkit.util = util_namespaceObject;\napi_UIkit.data = '__jdbpack__';\napi_UIkit.prefix = 'jdb-';\napi_UIkit.options = {};\n\nglobal(api_UIkit);\nhooks(api_UIkit);\napi_state(api_UIkit);\napi_component(api_UIkit);\ninstance(api_UIkit);\n\n/* harmony default export */ var api = (api_UIkit);\n\n// CONCATENATED MODULE: ./src/core/core.js\n\n\n/* harmony default export */ var core = (function (UIkit) {\n\n   ready(() => {\n\n      UIkit.update();\n      on(window, 'load resize', () => UIkit.update(null, 'resize'));\n      on(document, 'loadedmetadata load', ({target}) => UIkit.update(target, 'resize'), true);\n\n      // throttle `scroll` event (Safari triggers multiple `scroll` events per frame)\n      let pending;\n      on(window, 'scroll', e => {\n\n         if (pending) {\n            return;\n         }\n         pending = true;\n         fastdom.write(() => pending = false);\n\n         const {target} = e;\n         UIkit.update(target.nodeType !== 1 ? document.body : target, e.type);\n\n      }, {passive: true, capture: true});\n\n      let started = 0;\n      on(document, 'animationstart', ({target}) => {\n         if ((style_css(target, 'animationName') || '').match(/^uk-.*(left|right)/)) {\n\n            started++;\n            style_css(document.body, 'overflowX', 'hidden');\n            setTimeout(() => {\n               if (!--started) {\n                  style_css(document.body, 'overflowX', '');\n               }\n            }, Object(lang[\"toMs\"])(style_css(target, 'animationDuration')) + 100);\n      }\n      }, true);\n\n   });\n\n   let off;\n\n   on(document, pointerDown, e => {\n\n      off && off();\n\n      if (!isTouch(e)) {\n         return;\n      }\n\n      const pos = getEventPos(e);\n      const target = 'tagName' in e.target ? e.target : e.target.parentNode;\n      off = once(document, pointerUp, e => {\n\n         const {x, y} = getEventPos(e);\n\n         // swipe\n         if (target && x && Math.abs(pos.x - x) > 100 || y && Math.abs(pos.y - y) > 100) {\n\n            setTimeout(() => {\n               trigger(target, 'swipe');\n               trigger(target, `swipe${swipeDirection(pos.x, pos.y, x, y)}`);\n            });\n\n         }\n\n      });\n   }, {passive: true});\n\n});\n\nfunction swipeDirection(x1, y1, x2, y2) {\n   return Math.abs(x1 - x2) >= Math.abs(y1 - y2)\n           ? x1 - x2 > 0\n           ? 'Left'\n           : 'Right'\n           : y1 - y2 > 0\n           ? 'Up'\n           : 'Down';\n}\n\n// CONCATENATED MODULE: ./src/mixin/class.js\n\n\n/* harmony default export */ var mixin_class = ({\n\n    connected() {\n        !hasClass(this.$el, this.$name) && addClass(this.$el, this.$name);\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/core/jdbp/section.js\n\n\n/* harmony default export */ var section = ({\n\n   mixins: [mixin_class],\n\n   methods: {\n      init() {\n         style_css(this.$el, 'position', 'relative');\n         style_css(this.$el, 'width', document.body.clientWidth + 'px');\n         \n         let offsetTop, offsetLeft;\n         setTimeout(() => {\n            [offsetTop, offsetLeft] = offsetPosition(this.$el);\n\n            let _left = parseInt(style_css(this.$el, 'left'));\n\n            if (offsetLeft !== 0) {\n               style_css(this.$el, 'left', (_left + (0 - offsetLeft)) + 'px');\n            }\n         });\n      }\n   },\n\n   connected() {\n      this.init();\n   },\n\n   events: [\n\n      {\n         name: 'load resize',\n         el: window,\n         handler() {\n            this.init();\n         }\n      }\n   ],\n\n});\n\n// CONCATENATED MODULE: ./src/mixin/togglable.js\n\n\n/* harmony default export */ var togglable = ({\n\n    props: {\n        cls: Boolean,\n        animation: 'list',\n        duration: Number,\n        origin: String,\n        transition: String,\n        queued: Boolean\n    },\n\n    data: {\n        cls: false,\n        animation: [false],\n        duration: 200,\n        origin: false,\n        transition: 'linear',\n        queued: false,\n\n        initProps: {\n            overflow: '',\n            height: '',\n            paddingTop: '',\n            paddingBottom: '',\n            marginTop: '',\n            marginBottom: ''\n        },\n\n        hideProps: {\n            overflow: 'hidden',\n            height: 0,\n            paddingTop: 0,\n            paddingBottom: 0,\n            marginTop: 0,\n            marginBottom: 0\n        }\n\n    },\n\n    computed: {\n\n        hasAnimation({animation}) {\n            return !!animation[0];\n        },\n\n        hasTransition({animation}) {\n            return this.hasAnimation && animation[0] === true;\n        }\n\n    },\n\n    methods: {\n\n        toggleElement(targets, show, animate) {\n            return new util_promise[\"Promise\"](resolve => {\n\n                targets = Object(lang[\"toNodes\"])(targets);\n\n                const all = targets => util_promise[\"Promise\"].all(targets.map(el => this._toggleElement(el, show, animate)));\n                const toggled = targets.filter(el => this.isToggled(el));\n                const untoggled = targets.filter(el => !Object(lang[\"includes\"])(toggled, el));\n\n                let p;\n\n                if (!this.queued || !Object(lang[\"isUndefined\"])(animate) || !Object(lang[\"isUndefined\"])(show) || !this.hasAnimation || targets.length < 2) {\n\n                    p = all(untoggled.concat(toggled));\n\n                } else {\n\n                    const {body} = document;\n                    const scroll = body.scrollTop;\n                    const [el] = toggled;\n                    const inProgress = Animation.inProgress(el) && hasClass(el, 'jdb-animation-leave')\n                            || Transition.inProgress(el) && el.style.height === '0px';\n\n                    p = all(toggled);\n\n                    if (!inProgress) {\n                        p = p.then(() => {\n                            const p = all(untoggled);\n                            body.scrollTop = scroll;\n                            return p;\n                        });\n                    }\n\n                }\n\n                p.then(resolve, lang[\"noop\"]);\n\n            });\n        },\n\n        toggleNow(targets, show) {\n            return new util_promise[\"Promise\"](resolve => util_promise[\"Promise\"].all(Object(lang[\"toNodes\"])(targets).map(el => this._toggleElement(el, show, false))).then(resolve, lang[\"noop\"]));\n        },\n\n        isToggled(el) {\n            const nodes = Object(lang[\"toNodes\"])(el || this.$el);\n            return this.cls\n                ? hasClass(nodes, this.cls.split(' ')[0])\n                : !hasAttr(nodes, 'hidden');\n        },\n\n        updateAria(el) {\n            if (this.cls === false) {\n                attr(el, 'aria-hidden', !this.isToggled(el));\n            }\n        },\n\n        _toggleElement(el, show, animate) {\n\n            show = Object(lang[\"isBoolean\"])(show)\n                ? show\n                : Animation.inProgress(el)\n                    ? hasClass(el, 'jdb-animation-leave')\n                    : Transition.inProgress(el)\n                        ? el.style.height === '0px'\n                        : !this.isToggled(el);\n\n            if (!trigger(el, `before${show ? 'show' : 'hide'}`, [this])) {\n                return util_promise[\"Promise\"].reject();\n            }\n\n            const promise = (\n                Object(lang[\"isFunction\"])(animate)\n                    ? animate\n                    : animate === false || !this.hasAnimation\n                        ? this._toggle\n                        : this.hasTransition\n                            ? toggleHeight(this)\n                            : toggleAnimation(this)\n            )(el, show);\n\n            trigger(el, show ? 'show' : 'hide', [this]);\n\n            const final = () => {\n                trigger(el, show ? 'shown' : 'hidden', [this]);\n                this.$update(el);\n            };\n\n            return promise ? promise.then(final) : util_promise[\"Promise\"].resolve(final());\n        },\n\n        _toggle(el, toggled) {\n\n            if (!el) {\n                return;\n            }\n\n            toggled = Boolean(toggled);\n\n            let changed;\n            if (this.cls) {\n                changed = Object(lang[\"includes\"])(this.cls, ' ') || toggled !== hasClass(el, this.cls);\n                changed && toggleClass(el, this.cls, Object(lang[\"includes\"])(this.cls, ' ') ? undefined : toggled);\n            } else {\n                changed = toggled === hasAttr(el, 'hidden');\n                changed && attr(el, 'hidden', !toggled ? '' : null);\n            }\n\n            $$('[autofocus]', el).some(el => isVisible(el) ? el.focus() || true : el.blur());\n\n            this.updateAria(el);\n            changed && this.$update(el);\n        }\n\n    }\n\n});\n\nfunction toggleHeight({isToggled, duration, initProps, hideProps, transition, _toggle}) {\n    return (el, show) => {\n\n        const inProgress = Transition.inProgress(el);\n        const inner = el.hasChildNodes ? Object(lang[\"toFloat\"])(style_css(el.firstElementChild, 'marginTop')) + Object(lang[\"toFloat\"])(style_css(el.lastElementChild, 'marginBottom')) : 0;\n        const currentHeight = isVisible(el) ? dimensions_height(el) + (inProgress ? 0 : inner) : 0;\n\n        Transition.cancel(el);\n\n        if (!isToggled(el)) {\n            _toggle(el, true);\n        }\n\n        dimensions_height(el, '');\n\n        // Update child components first\n        fastdom.flush();\n\n        const endHeight = dimensions_height(el) + (inProgress ? 0 : inner);\n        dimensions_height(el, currentHeight);\n\n        return (show\n                ? Transition.start(el, Object(lang[\"assign\"])({}, initProps, {overflow: 'hidden', height: endHeight}), Math.round(duration * (1 - currentHeight / endHeight)), transition)\n                : Transition.start(el, hideProps, Math.round(duration * (currentHeight / endHeight)), transition).then(() => _toggle(el, false))\n        ).then(() => style_css(el, initProps));\n\n    };\n}\n\nfunction toggleAnimation({animation, duration, origin, _toggle}) {\n    return (el, show) => {\n\n        Animation.cancel(el);\n\n        if (show) {\n            _toggle(el, true);\n            return Animation.in(el, animation[0], duration, origin);\n        }\n\n        return Animation.out(el, animation[1] || animation[0], duration, origin).then(() => _toggle(el, false));\n    };\n}\n\n// CONCATENATED MODULE: ./src/core/jdbp/alert.js\n\n\n\n\n/* harmony default export */ var jdbp_alert = ({\n\n   mixins: [mixin_class, togglable],\n\n   args: 'animation',\n\n   props: {\n      close: String\n   },\n\n   data: {\n      animation: [true],\n      selClose: '.jdb-alert-close',\n      duration: 100,\n      hideProps: Object(lang[\"assign\"])({opacity: 0}, togglable.data.hideProps)\n   },\n\n   events: [\n\n      {\n\n         name: 'click',\n\n         delegate() {\n            return this.selClose;\n         },\n\n         handler(e) {\n            e.preventDefault();\n            this.close();\n         }\n\n      }\n\n   ],\n\n   methods: {\n\n      close() {\n         this.toggleElement(this.$el).then(() => this.$destroy(true));\n      }\n\n   }\n\n});\n\n// CONCATENATED MODULE: ./src/core/jdbp/accordion.js\n\n\n\n\n/* harmony default export */ var accordion = ({\n\n   mixins: [mixin_class, togglable],\n\n   props: {\n      targets: String,\n      active: null,\n      collapsible: Boolean,\n      multiple: Boolean,\n      toggle: String,\n      content: String,\n      transition: String\n   },\n\n   data: {\n      targets: '> *',\n      active: false,\n      animation: [true],\n      collapsible: true,\n      multiple: false,\n      clsOpen: 'jdb-active',\n      toggle: '> .jdb-accordion-title',\n      content: '> .jdb-accordion-content',\n      transition: 'ease'\n   },\n\n   computed: {\n\n      items( {targets}, $el) {\n         return $$(targets, $el);\n      }\n\n   },\n\n   events: [\n\n      {\n\n         name: 'click',\n\n         delegate() {\n            return `${this.targets} ${this.$props.toggle}`;\n         },\n\n         handler(e) {\n            e.preventDefault();\n            this.toggle(dom_index($$(`${this.targets} ${this.$props.toggle}`, this.$el), e.current));\n         }\n\n      }\n\n   ],\n\n   connected() {\n\n      if (this.active === false) {\n         return;\n      }\n\n      const active = this.items[Number(this.active)];\n      if (active && !hasClass(active, this.clsOpen)) {\n         this.toggle(active, false);\n      }\n   },\n\n   update() {\n\n      this.items.forEach(el => this._toggle($(this.content, el), hasClass(el, this.clsOpen)));\n\n      const active = !this.collapsible && !hasClass(this.items, this.clsOpen) && this.items[0];\n      if (active) {\n         this.toggle(active, false);\n      }\n   },\n\n   methods: {\n\n      toggle(item, animate) {\n\n         const index = getIndex(item, this.items);\n         const active = filter_filter(this.items, `.${this.clsOpen}`);\n\n         item = this.items[index];\n\n         item && [item]\n                 .concat(!this.multiple && !Object(lang[\"includes\"])(active, item) && active || [])\n                 .forEach(el => {\n\n                    const isItem = el === item;\n                    const state = isItem && !hasClass(el, this.clsOpen);\n\n                    if (!state && isItem && !this.collapsible && active.length < 2) {\n                       return;\n                    }\n\n                    toggleClass(el, this.clsOpen, state);\n\n                    const content = el._wrapper ? el._wrapper.firstElementChild : $(this.content, el);\n\n                    if (!el._wrapper) {\n                       el._wrapper = wrapAll(content, '<div>');\n                       attr(el._wrapper, 'hidden', state ? '' : null);\n                    }\n\n                    this._toggle(content, true);\n                    this.toggleElement(el._wrapper, state, animate).then(() => {\n\n                       if (hasClass(el, this.clsOpen) !== state) {\n                          return;\n                       }\n\n                       if (!state) {\n                          this._toggle(content, false);\n                       }\n\n                       el._wrapper = null;\n                       unwrap(content);\n\n                    });\n\n                 });\n      }\n\n   }\n\n});\n\n// CONCATENATED MODULE: ./src/core/switcher.js\n\n\n\n/* harmony default export */ var switcher = ({\n\n    mixins: [togglable],\n\n    args: 'connect',\n\n    props: {\n        connect: String,\n        toggle: String,\n        active: Number,\n        swiping: Boolean\n    },\n\n    data: {\n        connect: '~.jdb-switcher',\n        toggle: '> * > :first-child',\n        active: 0,\n        swiping: true,\n        cls: 'jdb-active',\n        clsContainer: 'jdb-switcher',\n        attrItem: 'jdb-switcher-item',\n        queued: true\n    },\n\n    computed: {\n\n        connects({connect}, $el) {\n            return queryAll(connect, $el);\n        },\n\n        toggles({toggle}, $el) {\n            return $$(toggle, $el);\n        }\n\n    },\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return `${this.toggle}:not(.jdb-disabled)`;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.show(Object(lang[\"toNodes\"])(this.$el.children).filter(el => within(e.current, el))[0]);\n            }\n\n        },\n\n        {\n            name: 'click',\n\n            el() {\n                return this.connects;\n            },\n\n            delegate() {\n                return `[${this.attrItem}],[data-${this.attrItem}]`;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.show(attr_data(e.current, this.attrItem));\n            }\n        },\n\n        {\n            name: 'swipeRight swipeLeft',\n\n            filter() {\n                return this.swiping;\n            },\n\n            el() {\n                return this.connects;\n            },\n\n            handler({type}) {\n                this.show(Object(lang[\"endsWith\"])(type, 'Left') ? 'next' : 'previous');\n            }\n        }\n\n    ],\n\n    update() {\n\n        this.connects.forEach(list => this.updateAria(list.children));\n        const {children} = this.$el;\n        this.show(filter_filter(children, `.${this.cls}`)[0] || children[this.active] || children[0]);\n\n    },\n\n    methods: {\n\n        index() {\n            return !Object(lang[\"isEmpty\"])(this.connects) && dom_index(filter_filter(this.connects[0].children, `.${this.cls}`)[0]);\n        },\n\n        show(item) {\n\n            const {children} = this.$el;\n            const {length} = children;\n            const prev = this.index();\n            const hasPrev = prev >= 0;\n            const dir = item === 'previous' ? -1 : 1;\n\n            let toggle, active, next = getIndex(item, children, prev);\n\n            for (let i = 0; i < length; i++, next = (next + dir + length) % length) {\n                if (!selector_matches(this.toggles[next], '.jdb-disabled *, .jdb-disabled, [disabled]')) {\n                    toggle = this.toggles[next];\n                    active = children[next];\n                    break;\n                }\n            }\n\n            if (!active || prev >= 0 && hasClass(active, this.cls) || prev === next) {\n                return;\n            }\n\n            removeClass(children, this.cls);\n            addClass(active, this.cls);\n            attr(this.toggles, 'aria-expanded', false);\n            attr(toggle, 'aria-expanded', true);\n\n            this.connects.forEach(list => {\n                if (!hasPrev) {\n                    this.toggleNow(list.children[next]);\n                } else {\n                    this.toggleElement([list.children[prev], list.children[next]]);\n                }\n            });\n\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/core/jdbp/tab.js\n\n\n\n\n/* harmony default export */ var tab = ({\n\n   mixins: [mixin_class],\n\n   extends: switcher,\n\n   props: {\n      media: Boolean\n   },\n\n   data: {\n      media: 960,\n      connect: '~.jdb-tab-contents',\n      attrItem: 'jdb-tab-item'\n   },\n\n   connected() {\n\n      const cls = hasClass(this.$el, 'jdb-tab-left')\n              ? 'jdb-tab-left'\n              : hasClass(this.$el, 'jdb-tab-right')\n              ? 'jdb-tab-right'\n              : false;\n\n      if (cls) {\n         this.$create('toggle', this.$el, {cls, mode: 'media', media: this.media});\n      }\n   }\n\n});\n\n// CONCATENATED MODULE: ./src/core/cover.js\n//import Video from './video';\n\n\n\n/* harmony default export */ var cover = ({\n\n    mixins: [mixin_class],\n\n    props: {\n        width: Number,\n        height: Number\n    },\n\n    data: {\n        automute: true\n    },\n\n    update: {\n\n        read() {\n\n            const el = this.$el;\n\n            if (!isVisible(el)) {\n                return false;\n            }\n\n            const {offsetHeight: height, offsetWidth: width} = el.parentNode;\n\n            return {height, width};\n        },\n\n        write({height, width}) {\n\n            const el = this.$el;\n            const elWidth = this.width || el.naturalWidth || el.videoWidth || el.clientWidth;\n            const elHeight = this.height || el.naturalHeight || el.videoHeight || el.clientHeight;\n\n            if (!elWidth || !elHeight) {\n                return;\n            }\n\n            style_css(el, lang[\"Dimensions\"].cover(\n                {\n                    width: elWidth,\n                    height: elHeight\n                },\n                {\n                    width: width + (width % 2 ? 1 : 0),\n                    height: height + (height % 2 ? 1 : 0)\n                }\n            ));\n\n        },\n\n        events: ['resize']\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/mixin/internal/slideshow-animations.js\n\n\n/* harmony default export */ var slideshow_animations = ({\n\n    slide: {\n\n        show(dir) {\n            return [\n                {transform: slideshow_animations_translate(dir * -100)},\n                {transform: slideshow_animations_translate()}\n            ];\n        },\n\n        percent(current) {\n            return translated(current);\n        },\n\n        translate(percent, dir) {\n            return [\n                {transform: slideshow_animations_translate(dir * -100 * percent)},\n                {transform: slideshow_animations_translate(dir * 100 * (1 - percent))}\n            ];\n        }\n\n    }\n\n});\n\nfunction translated(el) {\n    return Math.abs(style_css(el, 'transform').split(',')[4] / el.offsetWidth) || 0;\n}\n\nfunction slideshow_animations_translate(value = 0, unit = '%') {\n    return `translateX(${value}${value ? unit : ''})`; // currently not translate3d to support IE, translate3d within translate3d does not work while transitioning\n}\n\nfunction scale3d(value) {\n    return `scale3d(${value}, ${value}, 1)`;\n}\n\n// CONCATENATED MODULE: ./src/mixin/internal/slideshow-transitioner.js\n\n\nfunction Transitioner(prev, next, dir, {animation, easing}) {\n\n    const {percent, translate, show = lang[\"noop\"]} = animation;\n    const props = show(dir);\n    const deferred = new util_promise[\"Deferred\"]();\n\n    return {\n\n        dir,\n\n        show(duration, percent = 0, linear) {\n\n            const timing = linear ? 'linear' : easing;\n            duration -= Math.round(duration * Object(lang[\"clamp\"])(percent, -1, 1));\n\n            this.translate(percent);\n\n            triggerUpdate(next, 'itemin', {percent, duration, timing, dir});\n            triggerUpdate(prev, 'itemout', {percent: 1 - percent, duration, timing, dir});\n\n            util_promise[\"Promise\"].all([\n                Transition.start(next, props[1], duration, timing),\n                Transition.start(prev, props[0], duration, timing)\n            ]).then(() => {\n                this.reset();\n                deferred.resolve();\n            }, lang[\"noop\"]);\n\n            return deferred.promise;\n        },\n\n        stop() {\n            return Transition.stop([next, prev]);\n        },\n\n        cancel() {\n            Transition.cancel([next, prev]);\n        },\n\n        reset() {\n            for (const prop in props[0]) {\n                style_css([next, prev], prop, '');\n            }\n        },\n\n        forward(duration, percent = this.percent()) {\n            Transition.cancel([next, prev]);\n            return this.show(duration, percent, true);\n\n        },\n\n        translate(percent) {\n\n            this.reset();\n\n            const props = translate(percent, dir);\n            style_css(next, props[1]);\n            style_css(prev, props[0]);\n            triggerUpdate(next, 'itemtranslatein', {percent, dir});\n            triggerUpdate(prev, 'itemtranslateout', {percent: 1 - percent, dir});\n\n        },\n\n        percent() {\n            return percent(prev || next, next, dir);\n        },\n\n        getDistance() {\n            return prev && prev.offsetWidth;\n        }\n\n    };\n\n}\n\nfunction triggerUpdate(el, type, data) {\n    trigger(el, createEvent(type, false, false, data));\n}\n\n// CONCATENATED MODULE: ./src/mixin/slider-autoplay.js\n\n\n/* harmony default export */ var slider_autoplay = ({\n\n    props: {\n        autoplay: Boolean,\n        autoplayInterval: Number,\n        pauseOnHover: Boolean\n    },\n\n    data: {\n        autoplay: false,\n        autoplayInterval: 7000,\n        pauseOnHover: true\n    },\n\n    connected() {\n        this.autoplay && this.startAutoplay();\n    },\n\n    disconnected() {\n        this.stopAutoplay();\n    },\n\n    update() {\n        attr(this.slides, 'tabindex', '-1');\n    },\n\n    events: [\n\n        {\n\n            name: 'visibilitychange',\n\n            el: document,\n\n            filter() {\n                return this.autoplay;\n            },\n\n            handler() {\n                if (document.hidden) {\n                    this.stopAutoplay();\n                } else {\n                    this.startAutoplay();\n                }\n            }\n\n        },\n\n        {\n\n            name: 'mouseenter',\n\n            filter() {\n                return this.autoplay && this.pauseOnHover;\n            },\n\n            handler() {\n                this.isHovering = true;\n            }\n\n        },\n\n        {\n\n            name: 'mouseleave',\n\n            filter() {\n                return this.autoplay && this.pauseOnHover;\n            },\n\n            handler() {\n                this.isHovering = false;\n            }\n\n        }\n\n    ],\n\n    methods: {\n\n        startAutoplay() {\n\n            this.stopAutoplay();\n\n            this.interval = setInterval(\n                () => !within(document.activeElement, this.$el)\n                    && !this.isHovering\n                    && !this.stack.length\n                    && this.show('next'),\n                this.autoplayInterval\n            );\n\n        },\n\n        stopAutoplay() {\n            this.interval && clearInterval(this.interval);\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/mixin/slider-drag.js\n\n\n/* harmony default export */ var slider_drag = ({\n\n    props: {\n        draggable: Boolean\n    },\n\n    data: {\n        draggable: true,\n        threshold: 10\n    },\n\n    created() {\n\n        ['start', 'move', 'end'].forEach(key => {\n\n            const fn = this[key];\n            this[key] = e => {\n\n                const pos = getEventPos(e).x * (isRtl ? -1 : 1);\n\n                this.prevPos = pos !== this.pos ? this.pos : this.prevPos;\n                this.pos = pos;\n\n                fn(e);\n            };\n\n        });\n\n    },\n\n    events: [\n\n        {\n\n            name: pointerDown,\n\n            delegate() {\n                return this.selSlides;\n            },\n\n            handler(e) {\n\n                if (!this.draggable\n                    || !isTouch(e) && hasTextNodesOnly(e.target)\n                    || e.button > 0\n                    || this.length < 2\n                ) {\n                    return;\n                }\n\n                this.start(e);\n            }\n\n        },\n\n        {\n\n            // Workaround for iOS 11 bug: https://bugs.webkit.org/show_bug.cgi?id=184250\n\n            name: 'touchmove',\n            passive: false,\n            handler: 'move',\n            delegate() {\n                return this.selSlides;\n            }\n\n        },\n\n        {\n            name: 'dragstart',\n\n            handler(e) {\n                e.preventDefault();\n            }\n        }\n\n    ],\n\n    methods: {\n\n        start() {\n\n            this.drag = this.pos;\n\n            if (this._transitioner) {\n\n                this.percent = this._transitioner.percent();\n                this.drag += this._transitioner.getDistance() * this.percent * this.dir;\n\n                this._transitioner.cancel();\n                this._transitioner.translate(this.percent);\n\n                this.dragging = true;\n\n                this.stack = [];\n\n            } else {\n                this.prevIndex = this.index;\n            }\n\n            // See above workaround notice\n            const off = pointerMove !== 'touchmove'\n                ? on(document, pointerMove, this.move, {passive: false})\n                : lang[\"noop\"];\n            this.unbindMove = () => {\n                off();\n                this.unbindMove = null;\n            };\n            on(window, 'scroll', this.unbindMove);\n            on(document, pointerUp, this.end, true);\n\n            style_css(this.list, 'userSelect', 'none');\n\n        },\n\n        move(e) {\n\n            // See above workaround notice\n            if (!this.unbindMove) {\n                return;\n            }\n\n            const distance = this.pos - this.drag;\n\n            if (distance === 0 || this.prevPos === this.pos || !this.dragging && Math.abs(distance) < this.threshold) {\n                return;\n            }\n\n            style_css(this.list, 'pointerEvents', 'none');\n\n            e.cancelable && e.preventDefault();\n\n            this.dragging = true;\n            this.dir = (distance < 0 ? 1 : -1);\n\n            const {slides} = this;\n            let {prevIndex} = this;\n            let dis = Math.abs(distance);\n            let nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);\n            let width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;\n\n            while (nextIndex !== prevIndex && dis > width) {\n\n                this.drag -= width * this.dir;\n\n                prevIndex = nextIndex;\n                dis -= width;\n                nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);\n                width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;\n\n            }\n\n            this.percent = dis / width;\n\n            const prev = slides[prevIndex];\n            const next = slides[nextIndex];\n            const changed = this.index !== nextIndex;\n            const edge = prevIndex === nextIndex;\n\n            let itemShown;\n\n            [this.index, this.prevIndex].filter(i => !Object(lang[\"includes\"])([nextIndex, prevIndex], i)).forEach(i => {\n                trigger(slides[i], 'itemhidden', [this]);\n\n                if (edge) {\n                    itemShown = true;\n                    this.prevIndex = prevIndex;\n                }\n\n            });\n\n            if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {\n                trigger(slides[this.index], 'itemshown', [this]);\n            }\n\n            if (changed) {\n                this.prevIndex = prevIndex;\n                this.index = nextIndex;\n\n                !edge && trigger(prev, 'beforeitemhide', [this]);\n                trigger(next, 'beforeitemshow', [this]);\n            }\n\n            this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);\n\n            if (changed) {\n                !edge && trigger(prev, 'itemhide', [this]);\n                trigger(next, 'itemshow', [this]);\n            }\n\n        },\n\n        end() {\n\n            event_off(window, 'scroll', this.unbindMove);\n            this.unbindMove && this.unbindMove();\n            event_off(document, pointerUp, this.end, true);\n\n            if (this.dragging) {\n\n                this.dragging = null;\n\n                if (this.index === this.prevIndex) {\n                    this.percent = 1 - this.percent;\n                    this.dir *= -1;\n                    this._show(false, this.index, true);\n                    this._transitioner = null;\n                } else {\n\n                    const dirChange = (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 === this.prevPos > this.pos;\n                    this.index = dirChange ? this.index : this.prevIndex;\n\n                    if (dirChange) {\n                        this.percent = 1 - this.percent;\n                    }\n\n                    this.show(this.dir > 0 && !dirChange || this.dir < 0 && dirChange ? 'next' : 'previous', true);\n                }\n\n            }\n\n            style_css(this.list, {userSelect: '', pointerEvents: ''});\n\n            this.drag\n                = this.percent\n                = null;\n\n        }\n\n    }\n\n});\n\nfunction hasTextNodesOnly(el) {\n    return !el.children.length && el.childNodes.length;\n}\n\n// CONCATENATED MODULE: ./src/mixin/slider-nav.js\n\n\n/* harmony default export */ var slider_nav = ({\n\n    data: {\n        selNav: false\n    },\n\n    computed: {\n\n        nav({selNav}, $el) {\n            return $(selNav, $el);\n        },\n\n        selNavItem({attrItem}) {\n            return `[${attrItem}],[data-${attrItem}]`;\n        },\n\n        navItems(_, $el) {\n            return $$(this.selNavItem, $el);\n        }\n\n    },\n\n    update: {\n\n        write() {\n\n            if (this.nav && this.length !== this.nav.children.length) {\n                dom_html(this.nav, this.slides.map((_, i) => `<li ${this.attrItem}=\"${i}\"><a href=\"#\"></a></li>`).join(''));\n            }\n\n            toggleClass($$(this.selNavItem, this.$el).concat(this.nav), 'jdb-hidden', !this.maxIndex);\n\n            this.updateNav();\n\n        },\n\n        events: ['resize']\n\n    },\n\n    events: [\n\n        {\n\n            name: 'click',\n\n            delegate() {\n                return this.selNavItem;\n            },\n\n            handler(e) {\n                e.preventDefault();\n                this.show(attr_data(e.current, this.attrItem));\n            }\n\n        },\n\n        {\n\n            name: 'itemshow',\n            handler: 'updateNav'\n\n        }\n\n    ],\n\n    methods: {\n\n        updateNav() {\n\n            const i = this.getValidIndex();\n            this.navItems.forEach(el => {\n\n                const cmd = attr_data(el, this.attrItem);\n\n                toggleClass(el, this.clsActive, Object(lang[\"toNumber\"])(cmd) === i);\n                toggleClass(el, 'jdb-invisible', this.finite && (cmd === 'previous' && i === 0 || cmd === 'next' && i >= this.maxIndex));\n            });\n\n        }\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/mixin/slider.js\n\n\n\n\n\n/* harmony default export */ var slider = ({\n\n    mixins: [slider_autoplay, slider_drag, slider_nav],\n\n    props: {\n        clsActivated: Boolean,\n        easing: String,\n        index: Number,\n        finite: Boolean,\n        velocity: Number\n    },\n\n    data: () => ({\n        easing: 'ease',\n        finite: false,\n        velocity: 1,\n        index: 0,\n        stack: [],\n        percent: 0,\n        clsActive: 'jdb-active',\n        clsActivated: false,\n        Transitioner: false,\n        transitionOptions: {}\n    }),\n\n    computed: {\n\n        duration({velocity}, $el) {\n            return speedUp($el.offsetWidth / velocity);\n        },\n\n        length() {\n            return this.slides.length;\n        },\n\n        list({selList}, $el) {\n            return $(selList, $el);\n        },\n\n        maxIndex() {\n            return this.length - 1;\n        },\n\n        selSlides({selList}) {\n            return `${selList} > *`;\n        },\n\n        slides() {\n            return Object(lang[\"toNodes\"])(this.list.children);\n        }\n\n    },\n\n    events: {\n\n        itemshown() {\n            this.$update(this.list);\n        }\n\n    },\n\n    methods: {\n\n        show(index, force = false) {\n\n            if (this.dragging || !this.length) {\n                return;\n            }\n\n            const {stack} = this;\n            const queueIndex = force ? 0 : stack.length;\n            const reset = () => {\n                stack.splice(queueIndex, 1);\n\n                if (stack.length) {\n                    this.show(stack.shift(), true);\n                }\n            };\n\n            stack[force ? 'unshift' : 'push'](index);\n\n            if (!force && stack.length > 1) {\n\n                if (stack.length === 2) {\n                    this._transitioner.forward(Math.min(this.duration, 200));\n                }\n\n                return;\n            }\n\n            const prevIndex = this.index;\n            const prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];\n            const nextIndex = this.getIndex(index, this.index);\n            const next = this.slides[nextIndex];\n\n            if (prev === next) {\n                reset();\n                return;\n            }\n\n            this.dir = getDirection(index, prevIndex);\n            this.prevIndex = prevIndex;\n            this.index = nextIndex;\n\n            prev && trigger(prev, 'beforeitemhide', [this]);\n            if (!trigger(next, 'beforeitemshow', [this, prev])) {\n                this.index = this.prevIndex;\n                reset();\n                return;\n            }\n\n            const promise = this._show(prev, next, force).then(() => {\n\n                prev && trigger(prev, 'itemhidden', [this]);\n                trigger(next, 'itemshown', [this]);\n\n                return new util_promise[\"Promise\"](resolve => {\n                    fastdom.write(() => {\n                        stack.shift();\n                        if (stack.length) {\n                            this.show(stack.shift(), true);\n                        } else {\n                            this._transitioner = null;\n                        }\n                        resolve();\n                    });\n                });\n\n            });\n\n            prev && trigger(prev, 'itemhide', [this]);\n            trigger(next, 'itemshow', [this]);\n\n            return promise;\n\n        },\n\n        getIndex(index = this.index, prev = this.index) {\n            return Object(lang[\"clamp\"])(getIndex(index, this.slides, prev, this.finite), 0, this.maxIndex);\n        },\n\n        getValidIndex(index = this.index, prevIndex = this.prevIndex) {\n            return this.getIndex(index, prevIndex);\n        },\n\n        _show(prev, next, force) {\n\n            this._transitioner = this._getTransitioner(\n                prev,\n                next,\n                this.dir,\n                Object(lang[\"assign\"])({\n                    easing: force\n                        ? next.offsetWidth < 600\n                            ? 'cubic-bezier(0.25, 0.46, 0.45, 0.94)' /* easeOutQuad */\n                            : 'cubic-bezier(0.165, 0.84, 0.44, 1)' /* easeOutQuart */\n                        : this.easing\n                }, this.transitionOptions)\n            );\n\n            if (!force && !prev) {\n                this._transitioner.translate(1);\n                return util_promise[\"Promise\"].resolve();\n            }\n\n            const {length} = this.stack;\n            return this._transitioner[length > 1 ? 'forward' : 'show'](length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration, this.percent);\n\n        },\n\n        _getDistance(prev, next) {\n            return new this._getTransitioner(prev, prev !== next && next).getDistance();\n        },\n\n        _translate(percent, prev = this.prevIndex, next = this.index) {\n            const transitioner = this._getTransitioner(prev !== next ? prev : false, next);\n            transitioner.translate(percent);\n            return transitioner;\n        },\n\n        _getTransitioner(prev = this.prevIndex, next = this.index, dir = this.dir || 1, options = this.transitionOptions) {\n            return new this.Transitioner(\n                Object(lang[\"isNumber\"])(prev) ? this.slides[prev] : prev,\n                Object(lang[\"isNumber\"])(next) ? this.slides[next] : next,\n                dir * (isRtl ? -1 : 1),\n                options\n            );\n        }\n\n    }\n\n});\n\nfunction getDirection(index, prevIndex) {\n    return index === 'next'\n        ? 1\n        : index === 'previous'\n            ? -1\n            : index < prevIndex\n                ? -1\n                : 1;\n}\n\nfunction speedUp(x) {\n    return .5 * x + 300; // parabola through (400,500; 600,600; 1800,1200)\n}\n\n// CONCATENATED MODULE: ./src/mixin/slideshow.js\n\n\n\n\n\n/* harmony default export */ var slideshow = ({\n\n   mixins: [slider],\n\n   props: {\n      animation: String\n   },\n\n   data: {\n      animation: 'slide',\n      clsActivated: 'jdb-transition-active',\n      Animations: slideshow_animations,\n      Transitioner: Transitioner\n   },\n\n   computed: {\n\n      animation( {animation, Animations}) {\n         return Object(lang[\"assign\"])(animation in Animations ? Animations[animation] : Animations.slide, {name: animation});\n      },\n\n      transitionOptions() {\n         return {animation: this.animation};\n      }\n\n   },\n\n   events: {\n\n      'itemshow itemhide itemshown itemhidden'( {target}) {\n         this.$update(target);\n      },\n\n      itemshow() {\n         Object(lang[\"isNumber\"])(this.prevIndex) && fastdom.flush(); // iOS 10+ will honor the video.play only if called from a gesture handler\n      },\n\n      beforeitemshow( {target}) {\n         addClass(target, this.clsActive);\n      },\n\n      itemshown( {target}) {\n         addClass(target, this.clsActivated);\n      },\n\n      itemhidden( {target}) {\n         removeClass(target, this.clsActive, this.clsActivated);\n      }\n\n   }\n\n});\n\n// CONCATENATED MODULE: ./src/components/internal/slideshow-animations.js\n\n\n\n/* harmony default export */ var internal_slideshow_animations = (Object(lang[\"assign\"])({}, slideshow_animations, {\n\n    fade: {\n\n        show() {\n            return [\n                {opacity: 0, zIndex: 0},\n                {zIndex: -1}\n            ];\n        },\n\n        percent(current) {\n            return 1 - style_css(current, 'opacity');\n        },\n\n        translate(percent) {\n            return [\n                {opacity: 1 - percent, zIndex: 0},\n                {zIndex: -1}\n            ];\n        }\n\n    },\n\n    scale: {\n\n        show() {\n            return [\n                {opacity: 0, transform: scale3d(1 + .5), zIndex: 0},\n                {zIndex: -1}\n            ];\n        },\n\n        percent(current) {\n            return 1 - style_css(current, 'opacity');\n        },\n\n        translate(percent) {\n            return [\n                {opacity: 1 - percent, transform: scale3d(1 + .5 * percent), zIndex: 0},\n                {zIndex: -1}\n            ];\n        }\n\n    },\n\n    pull: {\n\n        show(dir) {\n            return dir < 0\n                ? [\n                    {transform: slideshow_animations_translate(30), zIndex: -1},\n                    {transform: slideshow_animations_translate(), zIndex: 0}\n                ]\n                : [\n                    {transform: slideshow_animations_translate(-100), zIndex: 0},\n                    {transform: slideshow_animations_translate(), zIndex: -1}\n                ];\n        },\n\n        percent(current, next, dir) {\n            return dir < 0\n                ? 1 - translated(next)\n                : translated(current);\n        },\n\n        translate(percent, dir) {\n            return dir < 0\n                ? [\n                    {transform: slideshow_animations_translate(30 * percent), zIndex: -1},\n                    {transform: slideshow_animations_translate(-100 * (1 - percent)), zIndex: 0}\n                ]\n                : [\n                    {transform: slideshow_animations_translate(-percent * 100), zIndex: 0},\n                    {transform: slideshow_animations_translate(30 * (1 - percent)), zIndex: -1}\n                ];\n        }\n\n    },\n\n    push: {\n\n        show(dir) {\n            return dir < 0\n                ? [\n                    {transform: slideshow_animations_translate(100), zIndex: 0},\n                    {transform: slideshow_animations_translate(), zIndex: -1}\n                ]\n                : [\n                    {transform: slideshow_animations_translate(-30), zIndex: -1},\n                    {transform: slideshow_animations_translate(), zIndex: 0}\n                ];\n        },\n\n        percent(current, next, dir) {\n            return dir > 0\n                ? 1 - translated(next)\n                : translated(current);\n        },\n\n        translate(percent, dir) {\n            return dir < 0\n                ? [\n                    {transform: slideshow_animations_translate(percent * 100), zIndex: 0},\n                    {transform: slideshow_animations_translate(-30 * (1 - percent)), zIndex: -1}\n                ]\n                : [\n                    {transform: slideshow_animations_translate(-30 * percent), zIndex: -1},\n                    {transform: slideshow_animations_translate(100 * (1 - percent)), zIndex: 0}\n                ];\n        }\n\n    }\n\n}));\n\n// CONCATENATED MODULE: ./src/mixin/slider-reactive.js\n\n\n/* harmony default export */ var slider_reactive = ({\n\n    update: {\n\n        write() {\n\n            if (this.stack.length || this.dragging) {\n                return;\n            }\n\n            const index = this.getValidIndex();\n            delete this.index;\n            removeClass(this.slides, this.clsActive, this.clsActivated);\n            this.show(index);\n\n        },\n\n        events: ['resize']\n\n    }\n\n});\n\n// CONCATENATED MODULE: ./src/core/jdbp/slideshow.js\n\n\n\n\n\n\n/* harmony default export */ var jdbp_slideshow = ({\n\n   mixins: [mixin_class, slideshow, slider_reactive],\n\n   props: {\n      ratio: String,\n      minHeight: Number,\n      maxHeight: Number\n   },\n\n   data: {\n      ratio: '16:9',\n      minHeight: false,\n      maxHeight: false,\n      selList: '.jdb-slider-items',\n      attrItem: 'jdb-slider-item',\n      selNav: '.jdb-slider-nav',\n      Animations: internal_slideshow_animations\n   },\n\n   update: {\n\n      read() {\n         try {\n\n            let [width, height] = this.ratio.split(':').map(Number);\n\n            height = height * this.list.offsetWidth / width || 0;\n\n            if (this.minHeight) {\n               height = Math.max(this.minHeight, height);\n            }\n\n            if (this.maxHeight) {\n               height = Math.min(this.maxHeight, height);\n            }\n            \n            return {height: height - boxModelAdjust(this.list, 'content-box')};\n         } catch (e) {\n         }\n      },\n\n      write( {height}) {\n         style_css(this.list, 'minHeight', height);\n      },\n\n      events: ['resize']\n\n   }\n\n});\n\n// CONCATENATED MODULE: ./src/core/jdbp/animation.js\n\n\n/* harmony default export */ var jdbp_animation = ({\n\n   mixins: [mixin_class],\n\n   props: {\n      type: String,\n      speed: String,\n      delay: String,\n      infinite: Boolean,\n   },\n\n   data: {\n      type: '',\n      speed: '',\n      delay: '',\n      infinite: false,\n   },\n\n   methods: {\n      init() {\n         if (isInView(this.$el) && !hasClass(this.$el, 'animated')) {\n            if (this.type != '') {\n               addClass(this.$el, this.type);\n            }\n            if (this.speed != '') {\n               addClass(this.$el, this.speed);\n            }\n            if (this.delay != '') {\n               addClass(this.$el, this.delay);\n            }\n            if (this.infinite) {\n               addClass(this.$el, 'infinite');\n            }\n            if (this.type != '') {\n               addClass(this.$el, 'animated');\n            }\n         }\n      }\n   },\n\n   connected() {\n      this.init();\n   },\n\n   events: [\n      {\n         name: 'scroll resize',\n         el: window,\n         handler() {\n            this.init();\n         }\n      }\n   ],\n\n});\n\n// CONCATENATED MODULE: ./src/core/index.js\n//import Accordion from './accordion';\n//import Alert from './alert';\n\n\n\n\n\n\n\n\n//import Drop from './drop';\n//import Dropdown from './dropdown';\n//import FormCustom from './form-custom';\n//import Gif from './gif';\n//import Grid from './grid';\n//import HeightMatch from './height-match';\n//import HeightViewport from './height-viewport';\n//import Icon, {IconComponent, Slidenav, Search, Close, Spinner} from './icon';\n//import Img from './img';\n//import Leader from './leader';\n//import Margin from './margin';\n//import Modal from './modal';\n//import Nav from './nav';\n//import Navbar from './navbar';\n//import Offcanvas from './offcanvas';\n//import OverflowAuto from './overflow-auto';\n//import Responsive from './responsive';\n//import Scroll from './scroll';\n//import Scrollspy from './scrollspy';\n//import ScrollspyNav from './scrollspy-nav';\n//import Sticky from './sticky';\n//import Svg from './svg';\n//import Switcher from './switcher';\n//import Tab from './tab';\n//import Toggle from './toggle';\n//import Video from './video';\n\n/* harmony default export */ var src_core = (function (UIkit) {\n\n   // core components\n   //UIkit.component('accordion', Accordion);\n   UIkit.component('section', section);\n   UIkit.component('alert', jdbp_alert);\n   UIkit.component('sliderContent', cover);\n   UIkit.component('accordion', accordion);\n   UIkit.component('tab', tab);\n   UIkit.component('slider', jdbp_slideshow);\n   UIkit.component('animation', jdbp_animation);\n   //UIkit.component('drop', Drop);\n   //UIkit.component('dropdown', Dropdown);\n   //UIkit.component('formCustom', FormCustom);\n   //UIkit.component('gif', Gif);\n   //UIkit.component('grid', Grid);\n   //UIkit.component('heightMatch', HeightMatch);\n   //UIkit.component('heightViewport', HeightViewport);\n   //UIkit.component('icon', Icon);\n   //UIkit.component('img', Img);\n   //UIkit.component('leader', Leader);\n   //UIkit.component('margin', Margin);\n   //UIkit.component('modal', Modal);\n   //UIkit.component('nav', Nav);\n   //UIkit.component('navbar', Navbar);\n   //UIkit.component('offcanvas', Offcanvas);\n   //UIkit.component('overflowAuto', OverflowAuto);\n   //UIkit.component('responsive', Responsive);\n   //UIkit.component('scroll', Scroll);\n   //UIkit.component('scrollspy', Scrollspy);\n   //UIkit.component('scrollspyNav', ScrollspyNav);\n   //UIkit.component('sticky', Sticky);\n   //UIkit.component('svg', Svg);\n   //UIkit.component('switcher', Switcher);\n   //UIkit.component('tab', Tab);\n   //UIkit.component('toggle', Toggle);\n   //UIkit.component('video', Video);\n\n   // Icon components\n   //UIkit.component('close', Close);\n   //UIkit.component('marker', IconComponent);\n   //UIkit.component('navbarToggleIcon', IconComponent);\n   //UIkit.component('overlayIcon', IconComponent);\n   //UIkit.component('paginationNext', IconComponent);\n   //UIkit.component('paginationPrevious', IconComponent);\n   //UIkit.component('searchIcon', Search);\n   //UIkit.component('slidenavNext', Slidenav);\n   //UIkit.component('slidenavPrevious', Slidenav);\n   //UIkit.component('spinner', Spinner);\n   //UIkit.component('totop', IconComponent);\n\n   // core functionality\n   UIkit.use(core);\n\n});\n\n// CONCATENATED MODULE: ./src/uikit-core.js\n\n\n\n\napi.version = '1.0.0';\n\nsrc_core(api);\n\nif (false) {}\n\n/* harmony default export */ var uikit_core = (api);\n\n// CONCATENATED MODULE: ./src/uikit.js\n\n\n\nif (true) {\n   boot(uikit_core);\n}\n\n/* harmony default export */ var uikit = __webpack_exports__[\"default\"] = (uikit_core);\n\n\n//# sourceURL=webpack://UIkit/./src/uikit.js_+_42_modules?");

/***/ }),

/***/ "./src/util/lang.js":
/*!**************************!*\
  !*** ./src/util/lang.js ***!
  \**************************/
/*! exports provided: bind, hasOwn, hyphenate, camelize, ucfirst, startsWith, endsWith, includes, findIndex, isArray, isFunction, isObject, isPlainObject, isWindow, isDocument, isJQuery, isNode, isNodeCollection, isBoolean, isString, isNumber, isNumeric, isEmpty, isUndefined, toBoolean, toNumber, toFloat, toNode, toNodes, toList, toMs, isEqual, swap, assign, each, sortBy, uniqueBy, clamp, noop, intersectRect, pointInRect, Dimensions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bind\", function() { return bind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasOwn\", function() { return hasOwn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hyphenate\", function() { return hyphenate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"camelize\", function() { return camelize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ucfirst\", function() { return ucfirst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startsWith\", function() { return startsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"endsWith\", function() { return endsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"includes\", function() { return includes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findIndex\", function() { return findIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isArray\", function() { return isArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFunction\", function() { return isFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isObject\", function() { return isObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPlainObject\", function() { return isPlainObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWindow\", function() { return isWindow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isDocument\", function() { return isDocument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isJQuery\", function() { return isJQuery; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNode\", function() { return isNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNodeCollection\", function() { return isNodeCollection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBoolean\", function() { return isBoolean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isString\", function() { return isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumber\", function() { return isNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumeric\", function() { return isNumeric; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isEmpty\", function() { return isEmpty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isUndefined\", function() { return isUndefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toBoolean\", function() { return toBoolean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toNumber\", function() { return toNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toFloat\", function() { return toFloat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toNode\", function() { return toNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toNodes\", function() { return toNodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toList\", function() { return toList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toMs\", function() { return toMs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isEqual\", function() { return isEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"swap\", function() { return swap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"each\", function() { return each; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sortBy\", function() { return sortBy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uniqueBy\", function() { return uniqueBy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clamp\", function() { return clamp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"noop\", function() { return noop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectRect\", function() { return intersectRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointInRect\", function() { return pointInRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dimensions\", function() { return Dimensions; });\nfunction bind(fn, context) {\n    return function (a) {\n        const l = arguments.length;\n        return l ? l > 1 ? fn.apply(context, arguments) : fn.call(context, a) : fn.call(context);\n    };\n}\n\nconst objPrototype = Object.prototype;\nconst {hasOwnProperty} = objPrototype;\n\nfunction hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n}\n\nconst hyphenateCache = {};\nconst hyphenateRe = /([a-z\\d])([A-Z])/g;\n\nfunction hyphenate(str) {\n\n    if (!(str in hyphenateCache)) {\n        hyphenateCache[str] = str\n            .replace(hyphenateRe, '$1-$2')\n            .toLowerCase();\n    }\n\n    return hyphenateCache[str];\n}\n\nconst camelizeRe = /-(\\w)/g;\n\nfunction camelize(str) {\n    return str.replace(camelizeRe, toUpper);\n}\n\nfunction toUpper(_, c) {\n    return c ? c.toUpperCase() : '';\n}\n\nfunction ucfirst(str) {\n    return str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : '';\n}\n\nconst strPrototype = String.prototype;\nconst startsWithFn = strPrototype.startsWith || function (search) { return this.lastIndexOf(search, 0) === 0; };\n\nfunction startsWith(str, search) {\n    return startsWithFn.call(str, search);\n}\n\nconst endsWithFn = strPrototype.endsWith || function (search) { return this.substr(-search.length) === search; };\n\nfunction endsWith(str, search) {\n    return endsWithFn.call(str, search);\n}\n\nconst arrPrototype = Array.prototype;\n\nconst includesFn = function (search, i) { return ~this.indexOf(search, i); };\nconst includesStr = strPrototype.includes || includesFn;\nconst includesArray = arrPrototype.includes || includesFn;\n\nfunction includes(obj, search) {\n    return obj && (isString(obj) ? includesStr : includesArray).call(obj, search);\n}\n\nconst findIndexFn = arrPrototype.findIndex || function (predicate) {\n    for (let i = 0; i < this.length; i++) {\n        if (predicate.call(arguments[1], this[i], i, this)) {\n            return i;\n        }\n    }\n    return -1;\n};\n\nfunction findIndex(array, predicate) {\n    return findIndexFn.call(array, predicate);\n}\n\nconst {isArray} = Array;\n\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\n\nfunction isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n}\n\nfunction isPlainObject(obj) {\n    return isObject(obj) && Object.getPrototypeOf(obj) === objPrototype;\n}\n\nfunction isWindow(obj) {\n    return isObject(obj) && obj === obj.window;\n}\n\nfunction isDocument(obj) {\n    return isObject(obj) && obj.nodeType === 9;\n}\n\nfunction isJQuery(obj) {\n    return isObject(obj) && !!obj.jquery;\n}\n\nfunction isNode(obj) {\n    return obj instanceof Node || isObject(obj) && obj.nodeType >= 1;\n}\n\nconst {toString} = objPrototype;\nfunction isNodeCollection(obj) {\n    return toString.call(obj).match(/^\\[object (NodeList|HTMLCollection)\\]$/);\n}\n\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\n\nfunction isString(value) {\n    return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n    return typeof value === 'number';\n}\n\nfunction isNumeric(value) {\n    return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));\n}\n\nfunction isEmpty(obj) {\n    return !(isArray(obj)\n        ? obj.length\n        : isObject(obj)\n            ? Object.keys(obj).length\n            : false\n    );\n}\n\nfunction isUndefined(value) {\n    return value === void 0;\n}\n\nfunction toBoolean(value) {\n    return isBoolean(value)\n        ? value\n        : value === 'true' || value === '1' || value === ''\n            ? true\n            : value === 'false' || value === '0'\n                ? false\n                : value;\n}\n\nfunction toNumber(value) {\n    const number = Number(value);\n    return !isNaN(number) ? number : false;\n}\n\nfunction toFloat(value) {\n    return parseFloat(value) || 0;\n}\n\nfunction toNode(element) {\n    return isNode(element) || isWindow(element) || isDocument(element)\n        ? element\n        : isNodeCollection(element) || isJQuery(element)\n            ? element[0]\n            : isArray(element)\n                ? toNode(element[0])\n                : null;\n}\n\nfunction toNodes(element) {\n    return isNode(element)\n        ? [element]\n        : isNodeCollection(element)\n            ? arrPrototype.slice.call(element)\n            : isArray(element)\n                ? element.map(toNode).filter(Boolean)\n                : isJQuery(element)\n                    ? element.toArray()\n                    : [];\n}\n\nfunction toList(value) {\n    return isArray(value)\n        ? value\n        : isString(value)\n            ? value.split(/,(?![^(]*\\))/).map(value => isNumeric(value)\n                ? toNumber(value)\n                : toBoolean(value.trim()))\n            : [value];\n}\n\nfunction toMs(time) {\n    return !time\n        ? 0\n        : endsWith(time, 'ms')\n            ? toFloat(time)\n            : toFloat(time) * 1000;\n}\n\nfunction isEqual(value, other) {\n    return value === other\n        || isObject(value)\n        && isObject(other)\n        && Object.keys(value).length === Object.keys(other).length\n        && each(value, (val, key) => val === other[key]);\n}\n\nfunction swap(value, a, b) {\n    return value.replace(new RegExp(`${a}|${b}`, 'mg'), match => {\n        return match === a ? b : a;\n    });\n}\n\nconst assign = Object.assign || function (target, ...args) {\n    target = Object(target);\n    for (let i = 0; i < args.length; i++) {\n        const source = args[i];\n        if (source !== null) {\n            for (const key in source) {\n                if (hasOwn(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n    }\n    return target;\n};\n\nfunction each(obj, cb) {\n    for (const key in obj) {\n        if (false === cb(obj[key], key)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction sortBy(array, prop) {\n    return array.sort(({[prop]: propA = 0}, {[prop]: propB = 0}) =>\n        propA > propB\n            ? 1\n            : propB > propA\n                ? -1\n                : 0\n    );\n}\n\nfunction uniqueBy(array, prop) {\n    const seen = new Set();\n    return array.filter(({[prop]: check}) => seen.has(check)\n        ? false\n        : seen.add(check) || true // IE 11 does not return the Set object\n    );\n}\n\nfunction clamp(number, min = 0, max = 1) {\n    return Math.min(Math.max(toNumber(number) || 0, min), max);\n}\n\nfunction noop() {}\n\nfunction intersectRect(r1, r2) {\n    return r1.left < r2.right &&\n        r1.right > r2.left &&\n        r1.top < r2.bottom &&\n        r1.bottom > r2.top;\n}\n\nfunction pointInRect(point, rect) {\n    return point.x <= rect.right &&\n        point.x >= rect.left &&\n        point.y <= rect.bottom &&\n        point.y >= rect.top;\n}\n\nconst Dimensions = {\n\n    ratio(dimensions, prop, value) {\n\n        const aProp = prop === 'width' ? 'height' : 'width';\n\n        return {\n            [aProp]: dimensions[prop] ? Math.round(value * dimensions[aProp] / dimensions[prop]) : dimensions[aProp],\n            [prop]: value\n        };\n    },\n\n    contain(dimensions, maxDimensions) {\n        dimensions = assign({}, dimensions);\n\n        each(dimensions, (_, prop) => dimensions = dimensions[prop] > maxDimensions[prop]\n            ? this.ratio(dimensions, prop, maxDimensions[prop])\n            : dimensions\n        );\n\n        return dimensions;\n    },\n\n    cover(dimensions, maxDimensions) {\n        dimensions = this.contain(dimensions, maxDimensions);\n\n        each(dimensions, (_, prop) => dimensions = dimensions[prop] < maxDimensions[prop]\n            ? this.ratio(dimensions, prop, maxDimensions[prop])\n            : dimensions\n        );\n\n        return dimensions;\n    }\n\n};\n\n\n//# sourceURL=webpack://UIkit/./src/util/lang.js?");

/***/ }),

/***/ "./src/util/promise.js":
/*!*****************************!*\
  !*** ./src/util/promise.js ***!
  \*****************************/
/*! exports provided: Promise, Deferred */
/*! ModuleConcatenation bailout: Module uses injected variables (setImmediate) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(setImmediate) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Promise\", function() { return Promise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Deferred\", function() { return Deferred; });\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./src/util/lang.js\");\n/* global setImmediate */\n\n\nconst Promise = 'Promise' in window ? window.Promise : PromiseFn;\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\n/**\n * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\n */\n\nconst RESOLVED = 0;\nconst REJECTED = 1;\nconst PENDING = 2;\n\nconst async = 'setImmediate' in window ? setImmediate : setTimeout;\n\nfunction PromiseFn(executor) {\n\n    this.state = PENDING;\n    this.value = undefined;\n    this.deferred = [];\n\n    const promise = this;\n\n    try {\n        executor(\n            x => {\n                promise.resolve(x);\n            },\n            r => {\n                promise.reject(r);\n            }\n        );\n    } catch (e) {\n        promise.reject(e);\n    }\n}\n\nPromiseFn.reject = function (r) {\n    return new PromiseFn((resolve, reject) => {\n        reject(r);\n    });\n};\n\nPromiseFn.resolve = function (x) {\n    return new PromiseFn((resolve, reject) => {\n        resolve(x);\n    });\n};\n\nPromiseFn.all = function all(iterable) {\n    return new PromiseFn((resolve, reject) => {\n        const result = [];\n        let count = 0;\n\n        if (iterable.length === 0) {\n            resolve(result);\n        }\n\n        function resolver(i) {\n            return function (x) {\n                result[i] = x;\n                count += 1;\n\n                if (count === iterable.length) {\n                    resolve(result);\n                }\n            };\n        }\n\n        for (let i = 0; i < iterable.length; i += 1) {\n            PromiseFn.resolve(iterable[i]).then(resolver(i), reject);\n        }\n    });\n};\n\nPromiseFn.race = function race(iterable) {\n    return new PromiseFn((resolve, reject) => {\n        for (let i = 0; i < iterable.length; i += 1) {\n            PromiseFn.resolve(iterable[i]).then(resolve, reject);\n        }\n    });\n};\n\nconst p = PromiseFn.prototype;\n\np.resolve = function resolve(x) {\n    const promise = this;\n\n    if (promise.state === PENDING) {\n        if (x === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        let called = false;\n\n        try {\n            const then = x && x.then;\n\n            if (x !== null && Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isObject\"])(x) && Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(then)) {\n                then.call(\n                    x,\n                    x => {\n                        if (!called) {\n                            promise.resolve(x);\n                        }\n                        called = true;\n                    },\n                    r => {\n                        if (!called) {\n                            promise.reject(r);\n                        }\n                        called = true;\n                    }\n                );\n                return;\n            }\n        } catch (e) {\n            if (!called) {\n                promise.reject(e);\n            }\n            return;\n        }\n\n        promise.state = RESOLVED;\n        promise.value = x;\n        promise.notify();\n    }\n};\n\np.reject = function reject(reason) {\n    const promise = this;\n\n    if (promise.state === PENDING) {\n        if (reason === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        promise.state = REJECTED;\n        promise.value = reason;\n        promise.notify();\n    }\n};\n\np.notify = function notify() {\n    async(() => {\n        if (this.state !== PENDING) {\n            while (this.deferred.length) {\n                const [onResolved, onRejected, resolve, reject] = this.deferred.shift();\n\n                try {\n                    if (this.state === RESOLVED) {\n                        if (Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(onResolved)) {\n                            resolve(onResolved.call(undefined, this.value));\n                        } else {\n                            resolve(this.value);\n                        }\n                    } else if (this.state === REJECTED) {\n                        if (Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(onRejected)) {\n                            resolve(onRejected.call(undefined, this.value));\n                        } else {\n                            reject(this.value);\n                        }\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            }\n        }\n    });\n};\n\np.then = function then(onResolved, onRejected) {\n    return new PromiseFn((resolve, reject) => {\n        this.deferred.push([onResolved, onRejected, resolve, reject]);\n        this.notify();\n    });\n};\n\np.catch = function (onRejected) {\n    return this.then(undefined, onRejected);\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack://UIkit/./src/util/promise.js?");

/***/ })

/******/ })["default"];
});